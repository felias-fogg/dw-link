{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"An Arduino-based debugWIRE debugger: dw-link What can you do when you want to debug your Arduino project on an ATmega328P or on a classic ATtiny? In theory, it should be possible to use on-chip debugging via the debugWIRE interface, which can be accessed by utilizing a so-called hardware debugger . If you do not own such a hardware debugger but would like to try it, then dw-link is the right thing for you. It turns an Arduino UNO into a hardware debugger. It can be used stand-alone (using the symbolic debugger AVR-GDB in a console window), or you can use it as part of the Arduino IDE 2 or other IDEs. Check out the quickstart guides! If you are looking for a more durable debugging solution, I recommend MPLAB SNAP (or any other EDBG-based Microchip debugger). When employing the GDB server PyAvrOCD (perhaps implicitly by using the Arduino IDE 2), SNAP is a drop-in replacement for dw-link, and it can do much more than dw-link.","title":"An Arduino-based debugWIRE debugger: dw-link"},{"location":"#an-arduino-based-debugwire-debugger-dw-link","text":"What can you do when you want to debug your Arduino project on an ATmega328P or on a classic ATtiny? In theory, it should be possible to use on-chip debugging via the debugWIRE interface, which can be accessed by utilizing a so-called hardware debugger . If you do not own such a hardware debugger but would like to try it, then dw-link is the right thing for you. It turns an Arduino UNO into a hardware debugger. It can be used stand-alone (using the symbolic debugger AVR-GDB in a console window), or you can use it as part of the Arduino IDE 2 or other IDEs. Check out the quickstart guides! If you are looking for a more durable debugging solution, I recommend MPLAB SNAP (or any other EDBG-based Microchip debugger). When employing the GDB server PyAvrOCD (perhaps implicitly by using the Arduino IDE 2), SNAP is a drop-in replacement for dw-link, and it can do much more than dw-link.","title":"An Arduino-based debugWIRE debugger: dw-link"},{"location":"acknowledgements/","text":"Acknowledgements First, I would like to thank everyone who made the work described here possible by making their work public: RikusW, who published his results on reverse engineering the debugWIRE protocol , dcbrown , who wrote dwire-debug , a debugger using only an USB-UART converter. I was never able to get it running on my Mac, but it provided me with a lot of important information. DeqingSun, who was the first one to integrate the open-source debugWIRE GDB server dwire-debug into the Arduino IDE 2, tito , who's stk500 implementation I used as a base for the dw-uploader script, wholder , who wrote the Uno-based debugger DebugWireDebuggerProgrammer , jdolinay , who wrote the GDB remote stub for AVRs avr_debug , MCUdude , who is the author of MiniCore and MicroCore , and SpenceKonde , who is the author of ATTinyCore . Of course, my thanks go also to everybody else, who contributed to the Arduino project. Last, but not least, I would like to thank everybody who contributed to dw-link: kristianwiklund , and MikeChen08 . The cover picture was designed based on vector graphics by captainvector at 123RF .","title":"Acknowledgements"},{"location":"acknowledgements/#acknowledgements","text":"First, I would like to thank everyone who made the work described here possible by making their work public: RikusW, who published his results on reverse engineering the debugWIRE protocol , dcbrown , who wrote dwire-debug , a debugger using only an USB-UART converter. I was never able to get it running on my Mac, but it provided me with a lot of important information. DeqingSun, who was the first one to integrate the open-source debugWIRE GDB server dwire-debug into the Arduino IDE 2, tito , who's stk500 implementation I used as a base for the dw-uploader script, wholder , who wrote the Uno-based debugger DebugWireDebuggerProgrammer , jdolinay , who wrote the GDB remote stub for AVRs avr_debug , MCUdude , who is the author of MiniCore and MicroCore , and SpenceKonde , who is the author of ATTinyCore . Of course, my thanks go also to everybody else, who contributed to the Arduino project. Last, but not least, I would like to thank everybody who contributed to dw-link: kristianwiklund , and MikeChen08 . The cover picture was designed based on vector graphics by captainvector at 123RF .","title":"Acknowledgements"},{"location":"better/","text":"Better hardware for the hardware debugger The hardware part of our hardware debugger is very limited so far. You can, of course, use six jumper wires to connect dw-link to your target as described in the hardware setup section . However, if you want to use this tool more than once, then there should be at least something like an ISP cable connection. Otherwise, you might scratch your head, wondering which cable goes where every time you start a debugging session. The basic solution For most of the wires, we use the same pins on the debugger and the target. Moreover, most of the pins are connected to the ISP connector on the board. So, it makes sense to think about something similar to an ISP cable that people use when employing an Arduino UNO as an ISP programmer. Such cables can be easily constructed with some Dupont wires and a bit of heat shrink tube, as, for example, demonstrated in this instructable . In contrast to such a programmer cable, it also makes sense to break out the Vcc wire. And you do not want to integrate a capacitor between RESET and GND in such a cable, in contrast to what is described in the instructable! As argued in my blog post on being cheap , with such an ISP cable, we have sort of constructed a hardware debugger for less than 10\u20ac, which can be considered semi-durable. Just add the optional system LED with an attached resistor and a capacitor between RESET and GND. The relevant pins are defined in the following table. Arduino pin ISP pin Function D13 3 SCK D12 1 MISO D11 4 MOSI 5V 2 VTG D8 5 RESET GND 6 GND D7 System LED+ D6 System LED- (if using a LED with a resistor soldered on) A simple prototype shield Taking it one step further, one can take a prototype shield for an UNO, put an ISP socket on it, and connect the socket to the respective shield pins. You should also plan to have jumper pins to to be able to power-cycle the target. Finally, you probably also want to place the system LED on the board. So, it could look like the following Fritzing sketch. Adapter with level-shifters and switchable power supply The basic adapter is quite limited. Power-cycling has to be done manually, it cannot interact with 3.3 V systems, and it has a high load on the SCK line (because the UNO LED is driven by this pin) when the ISP mode is disabled. Thus, it would be great to have a board with the following features: switchable target power supply (supporting power-cycling by the hardware debugger) offering 5-volt and 3.3-volt supply up to 300 mA, a bidirectional (conditional) level-shifter on the debugWIRE/RESET line, an optional pull-up resistor of 10 k\u03a9 on this line, unidirectional (conditional) level-shifters on the ISP lines, and high-impedance status for the two output signals MOSI and SCK when ISP is inactive. Such a board does not need to be very complex. The electronic design is minimalistic. It uses just three MOS-FETs, one LED, one voltage regulator, and some passive components. We need to (conditionally) level-shift the RESET line in a bidirectional manner and the SPI lines unidirectionally. One needs to shift the MISO line from 3.3-5 V up to 5 V, and the MOSI and SCK lines from 5 V down to 3.3-5 V. For the former case, no level shifting is done at all, relying on the fact that the input pins of the hardware debugger recognize a logical one already at 3.0 V. For the RESET line, which is open drain, we rely on the same fact. This means that this hardware debugger cannot deal with systems that use a supply voltage of less than 3 V, though. For downshifting, we use the output pins of the hardware debugger in an open drain configuration and have pull-up resistors connected to the target supply voltage. These have to be particularly strong because some possible target boards, e.g., the Arduino UNO, use the SCK line for driving an LED with a series resistor of 1k\u03a9. For this reason, we use 680\u03a9 pull-up resistors that guarantee that the signal level is above 3V on the SCK line, when we supply the board with 5V. These pull-ups will be disabled when no ISP programming is active, giving the target system full control of the two lines. The schematic looks as follows (thanks to gwideman for the reworked schematic). The pin mapping is a bit different from the basic design described above. The change from the basic mapping is controlled by pin D5, which is tied to GND in order to signal that the more complex pin mapping is used. The additional pins are all in italics. The ones not used on the board are struck out. Arduino pin ISP pin Function D13 3 SCK D12 1 MISO D11 4 MOSI (open drain) D10 3 SCK (open drain) 5V 2 VTG D8 5 RESET GND 6 GND D7 System LED+ D6 System LED- (if using an LED with a resistor soldered on) D5 Sense pin: Connected to GND when a board with a level shifter is used D4 ISP pull-up enable (open drain, active low) D3 Input: automatic debugWire switching disable (open drain, active low) D2 Power enable (open drain, active low) 2 VTG: Power from Q1 controlled by power jumper And here is the early breadboard prototype, which worked beautifully. I have turned the prototype into an Arduino Shield, which I sold at Tindie as a kit. With that, the hardware setup is straightforward. Just plug in an ISP cable, and you can start debugging. Before you start, you have to configure three jumpers. Then you are all set. Label Left Middle Right Supply 5 V are supplied to the target extern : target needs its own supply and power cycling has to be done manually 3.3 V are supplied to the target Pullup There is no pull-up resistor connected to RESET A 10 k\u03a9 pull-up resistor is connected to the RESET line of the target Auto_DW Automatic power-cycling is disabled in the off state. Automatic power-cycling when executing monitor debugwire enable is enabled in the on state. This is the default and recommended mode. Since the hardware debugger MPLAB SNAP has become cheaper than this kit, I decided to retire the kit, and now recommend to buy a SNAP . Together with my Python package PyAvrOCD , you get the same debugging experience. Furthermore, you will also be able to debug other AVRs than only debugWIRE MCUs.","title":"A better hardware debugger"},{"location":"better/#better-hardware-for-the-hardware-debugger","text":"The hardware part of our hardware debugger is very limited so far. You can, of course, use six jumper wires to connect dw-link to your target as described in the hardware setup section . However, if you want to use this tool more than once, then there should be at least something like an ISP cable connection. Otherwise, you might scratch your head, wondering which cable goes where every time you start a debugging session.","title":"Better hardware for the hardware debugger"},{"location":"better/#the-basic-solution","text":"For most of the wires, we use the same pins on the debugger and the target. Moreover, most of the pins are connected to the ISP connector on the board. So, it makes sense to think about something similar to an ISP cable that people use when employing an Arduino UNO as an ISP programmer. Such cables can be easily constructed with some Dupont wires and a bit of heat shrink tube, as, for example, demonstrated in this instructable . In contrast to such a programmer cable, it also makes sense to break out the Vcc wire. And you do not want to integrate a capacitor between RESET and GND in such a cable, in contrast to what is described in the instructable! As argued in my blog post on being cheap , with such an ISP cable, we have sort of constructed a hardware debugger for less than 10\u20ac, which can be considered semi-durable. Just add the optional system LED with an attached resistor and a capacitor between RESET and GND. The relevant pins are defined in the following table. Arduino pin ISP pin Function D13 3 SCK D12 1 MISO D11 4 MOSI 5V 2 VTG D8 5 RESET GND 6 GND D7 System LED+ D6 System LED- (if using a LED with a resistor soldered on)","title":"The basic solution"},{"location":"better/#a-simple-prototype-shield","text":"Taking it one step further, one can take a prototype shield for an UNO, put an ISP socket on it, and connect the socket to the respective shield pins. You should also plan to have jumper pins to to be able to power-cycle the target. Finally, you probably also want to place the system LED on the board. So, it could look like the following Fritzing sketch.","title":"A simple prototype shield"},{"location":"better/#adapter-with-level-shifters-and-switchable-power-supply","text":"The basic adapter is quite limited. Power-cycling has to be done manually, it cannot interact with 3.3 V systems, and it has a high load on the SCK line (because the UNO LED is driven by this pin) when the ISP mode is disabled. Thus, it would be great to have a board with the following features: switchable target power supply (supporting power-cycling by the hardware debugger) offering 5-volt and 3.3-volt supply up to 300 mA, a bidirectional (conditional) level-shifter on the debugWIRE/RESET line, an optional pull-up resistor of 10 k\u03a9 on this line, unidirectional (conditional) level-shifters on the ISP lines, and high-impedance status for the two output signals MOSI and SCK when ISP is inactive. Such a board does not need to be very complex. The electronic design is minimalistic. It uses just three MOS-FETs, one LED, one voltage regulator, and some passive components. We need to (conditionally) level-shift the RESET line in a bidirectional manner and the SPI lines unidirectionally. One needs to shift the MISO line from 3.3-5 V up to 5 V, and the MOSI and SCK lines from 5 V down to 3.3-5 V. For the former case, no level shifting is done at all, relying on the fact that the input pins of the hardware debugger recognize a logical one already at 3.0 V. For the RESET line, which is open drain, we rely on the same fact. This means that this hardware debugger cannot deal with systems that use a supply voltage of less than 3 V, though. For downshifting, we use the output pins of the hardware debugger in an open drain configuration and have pull-up resistors connected to the target supply voltage. These have to be particularly strong because some possible target boards, e.g., the Arduino UNO, use the SCK line for driving an LED with a series resistor of 1k\u03a9. For this reason, we use 680\u03a9 pull-up resistors that guarantee that the signal level is above 3V on the SCK line, when we supply the board with 5V. These pull-ups will be disabled when no ISP programming is active, giving the target system full control of the two lines. The schematic looks as follows (thanks to gwideman for the reworked schematic). The pin mapping is a bit different from the basic design described above. The change from the basic mapping is controlled by pin D5, which is tied to GND in order to signal that the more complex pin mapping is used. The additional pins are all in italics. The ones not used on the board are struck out. Arduino pin ISP pin Function D13 3 SCK D12 1 MISO D11 4 MOSI (open drain) D10 3 SCK (open drain) 5V 2 VTG D8 5 RESET GND 6 GND D7 System LED+ D6 System LED- (if using an LED with a resistor soldered on) D5 Sense pin: Connected to GND when a board with a level shifter is used D4 ISP pull-up enable (open drain, active low) D3 Input: automatic debugWire switching disable (open drain, active low) D2 Power enable (open drain, active low) 2 VTG: Power from Q1 controlled by power jumper And here is the early breadboard prototype, which worked beautifully. I have turned the prototype into an Arduino Shield, which I sold at Tindie as a kit. With that, the hardware setup is straightforward. Just plug in an ISP cable, and you can start debugging. Before you start, you have to configure three jumpers. Then you are all set. Label Left Middle Right Supply 5 V are supplied to the target extern : target needs its own supply and power cycling has to be done manually 3.3 V are supplied to the target Pullup There is no pull-up resistor connected to RESET A 10 k\u03a9 pull-up resistor is connected to the RESET line of the target Auto_DW Automatic power-cycling is disabled in the off state. Automatic power-cycling when executing monitor debugwire enable is enabled in the on state. This is the default and recommended mode. Since the hardware debugger MPLAB SNAP has become cheaper than this kit, I decided to retire the kit, and now recommend to buy a SNAP . Together with my Python package PyAvrOCD , you get the same debugging experience. Furthermore, you will also be able to debug other AVRs than only debugWIRE MCUs.","title":"Adapter with level-shifters and switchable power supply"},{"location":"debugging/","text":"Debugging Now we can do serious business ... Command-line interface debugging Using avr-gdb, the GDB version for AVR chips, is straightforward, provided avr-gdb is already installed. After compiling your program, you need to start the avr-gdb debugger, giving the name of the binary as an argument. Once inside GDB, you need to set the baud rate and then connect to dw-link using the serial line, as shown below. Since the hardware debugger is platform agnostic, this will work with all operating systems. > avr-gdb program.ino.elf GNU gdb ... ... (gdb) set serial baud 115200 (gdb) target remote /dev/cu.usbmodem1234 Remote debugging using /dev/cu.usbmodem1234 0x00000000 in __vectors () (gdb) monitor debugwire enable *** Please power-cycle target *** Ignoring packet error, continuing... Connected to ATmega328P debugWIRE is enabled, bps: 125244 (gdb) If you have come to this point, I trust that you know what you are doing and know how to proceed from there. Arduino IDE 2 debugging If, instead, you want to use dw-link in the Arduino IDE 2, read on. Using dw-link in the Arduino IDE 2 is straightforward. Before starting, you must install only some new board manager URLs and the respective board packages . And then you can use the debugging feature of the Arduino IDE 2. Compiling the sketch You must load the sketch into the editor and select a board as usual. If you want to debug an Arduino UNO board, choose ATmega328 from the Minicore in the Tools menu. Before clicking the Verify button in the upper left corner, choose Optimize for Debugging in the Sketch menu. This is necessary so that the compiler optimizes the code in a way that makes debugging straightforward. Otherwise, the compiler may rearrange source code lines, and one will get confused when single-stepping through the code. Debugging After having verified the sketch (which also compiled it), it is time to start debugging by clicking on the debug button in the top row. This will start the debug server, which will notice that the MCU is not yet in debugWIRE mode and ask you to power-cycle the target board by displaying a message to that effect. Instead of the message shown in the following screenshot, it may happen that a warning \"No hardware debugger discovered\" is shown. The reason may be that the Arduino IDE 2 reserved the debugger's serial line for the Serial Monitor . Close the Serial Monitor console and try again. As mentioned in Section 2, power cycling is only necessary once. The next time you start a debugging session, the MCU will already be in debugWIRE mode, and the debugger will not stop at this point. After power-cycling the target, the debugger starts. Eventually, execution is stopped in line 35 of the Arduino internal file main.cpp at an initial internal breakpoint, indicated by the yellow triangle left of the line in the following screenshot. It might take a while before we reach that point because the debugger must also load the program. After stopping, the IDE rearranges the layout, showing the debugging panes on the left and the sketch on the right. It will also switch from showing the gdb-server console to the Debug Console , which shows the output of the GDB debugger. Now is a good time to familiarize yourself with the window's layout. The source code is on the right side. Below that is a console window, and to the left are the debug panes. If you want to set a breakpoint, you can do that by clicking to the left of the line numbers. Such breakpoints are displayed as red dots, such as those left of lines 8 and 13. The debugging panes are organized as follows. Pane A contains the debug controls. From left to right: Reset ting the device Continue execution or pause Step over : execute one source line Step into : execute stepping into the function, if in this line one is called Step out : finish the current function and stop after the line where it was called Restart : Same as Reset Stop : Terminate debugging Pane B shows the active threads, but there is just one in our case. Pane C displays the call stack starting from the bottom, i.e., the current frame is the topmost. Pane D displays variable values. Unfortunately, global variables are not shown. Pane E can be populated with watch expressions. Finally, in pane F, the active breakpoints are listed. The panes below are useless in our case. Some more information about debugging can be found in the Arduino debugging tutorial . Some Pro Tips If you want to switch from the dw-link debugger to a professional hardware debugger, e.g., MPLAP SNAP or Atmel-ICE , these debuggers can be used as a drop-in replacement! So you do not have to change anything in the hardware or software configuration. And the SNAP is really cheap these days! The I/O registers are displayed in the CORTEX PERIPHERALS debugger pane. There, you can also change single register values. Global variables are, by default, not displayed. However, you can set a watch expression in the Watch pane to display a global variable's value. Or you can disable link time optimization (LTO) in the Tools menu. Then all global variables show up, except for one (which is an error of the IDE). If you select the Debug Console, you can type GDB commands in the bottom line. This can be useful for changing the value of global variables using the GDB command set var <varname>=<value> . This can also be used to disable the debugWIRE mode using the command monitor debugwire disable . The following section describes more monitor commands. Monitor commands Command Action monitor atexit [ stayindebugwire | leavedebugwire ] When specifying leavedebugwire , then debugWIRE mode will be left when exiting the debugger. This is useful when dealing with embedded debuggers such as the Xplained Mini boards. The default is stayindebugwire , i.e., debugWIREmode will not be left when exiting the debugger. monitor breakpoints [ all | software | hardware ] Restricts the kind of breakpoints that can be used. Either all types are permitted, only software breakpoints are allowed, or only hardware breakpoints can be used. Using all kinds is the default. monitor caching [ enable | disable ] This command is not implemented in dw-link. monitor debugwire [ enable | disable ] DebugWIRE mode will be enable d or disable d. When enabling it, the MCU will be reset, and you may be asked to power-cycle the target. After disabling debugWIRE mode, one has to exit the debugger. Afterward, the MCU can be programmed again using SPI programming. monitor erasebeforeload [ enable | disable ] This command is not implemented in dw-link because there is no way to erase the flash memory in debugWIRE mode. monitor help Display help text. monitor info Display information about the target and the state of the debugger. monitor load [ readbeforewrite | writeonly | onlycache ] When loading an executable, either each flash page is compared with the content to be loaded, and flashing is skipped if the content is already there ( readbeforewrite ), or each flash page is written without reading the current contents beforehand ( writeonly ). The first option is the default option for debugWIRE targets. For JTAG targets, the overhead of checking whether the page content is identical is so high that the writeonly option is the default. The third option ( onlycache ) will disable loading code into flash memory, but only fill the cache of PyAvrOCD. This is useful when one knows that the code is already loaded and one wants to avoid the overhead of reading flash memory content. monitor onlywhenloaded [ enable | disable ] Execution is only possible when a load command was previously executed, which is the default. If you want to start execution without loading an executable first, you need to disable this mode. monitor rangestepping [ enable | disable ] The GDB range-stepping command is supported or disabled. The default is that it is enable d. monitor reset Resets the MCU. monitor singlestep [ safe | interruptible ] Single-stepping can be performed in a safe way, where single steps are shielded against interrupts. Otherwise, a single step can lead to a jump into the interrupt dispatch table. The safe option is the default. monitor timer [ run | freeze ] Timers can either be frozen when execution is stopped, or they can run freely. The latter option is helpful when PWM output is crucial, and it is the default. monitor verify [ enable | disable ] Verify flash after loading each flash page. The default setting is for this option to be enable d. monitor version Show version of the gdbserver. All commands can, as usual, be abbreviated. For example, mo d e is equivalent to monitor debugwire enable . If you use a command without an argument, the current setting is printed. All state-changing commands (except debugwire ) can also be specified as command-line options when invoking PyAvrOCD, e.g., --verify disable . Restoring an Uno to its native state When you want to restore the target so that it behaves again like an ordinary UNO after a debugging session, you have two options: you can restore it as a MiniCore 328P board or as an original UNO board. The former one is the more attractive alternative in my eyes. Just check out the pages about MiniCore . Further, the command Burn Bootloader does apparently not work so well with some programmers or debuggers when doing it for the Uno setting. However, the dw-link built-in programmer has no problems. In order to restore your board, you need to do the following steps: You need the target board to exit the debugWIRE mode. This could be done by typing monitor debugwire disable into the debugger just before exiting. Or it will be done automagically using the built-in programmer mentioned in the following step. Now you have to flash the bootloader. Since version 2.2.0, the hardware debugger can also act as a programmer! This means that you leave the whole hardware setup as it was. However, you can, of course, use any other ISP programmer. Select Arduino UNO or the ATmega328 board as the target board in the Tools menu, select AVR ISP as the Programmer, choose the correct serial port, and use Burn Bootloader from the Tools menu. This will revert the MCU to its normal state (if it is still in debugWARE state) and will restore the fuses, the bootloader, and the lock bits to their original state. Reestablish the RESET EN connection by putting a solder blob on the connection or soldering pins to the connections that can be shortened using a jumper, as shown in the following picture. It does not look pretty, but it does its job. After that, your UNO is as good as new. Note that in the future, code uploading should be done by choosing the type of board you used when executing the Burn Bootloader command.","title":"Debugging"},{"location":"debugging/#debugging","text":"Now we can do serious business ...","title":"Debugging"},{"location":"debugging/#command-line-interface-debugging","text":"Using avr-gdb, the GDB version for AVR chips, is straightforward, provided avr-gdb is already installed. After compiling your program, you need to start the avr-gdb debugger, giving the name of the binary as an argument. Once inside GDB, you need to set the baud rate and then connect to dw-link using the serial line, as shown below. Since the hardware debugger is platform agnostic, this will work with all operating systems. > avr-gdb program.ino.elf GNU gdb ... ... (gdb) set serial baud 115200 (gdb) target remote /dev/cu.usbmodem1234 Remote debugging using /dev/cu.usbmodem1234 0x00000000 in __vectors () (gdb) monitor debugwire enable *** Please power-cycle target *** Ignoring packet error, continuing... Connected to ATmega328P debugWIRE is enabled, bps: 125244 (gdb) If you have come to this point, I trust that you know what you are doing and know how to proceed from there.","title":"Command-line interface debugging"},{"location":"debugging/#arduino-ide-2-debugging","text":"If, instead, you want to use dw-link in the Arduino IDE 2, read on. Using dw-link in the Arduino IDE 2 is straightforward. Before starting, you must install only some new board manager URLs and the respective board packages . And then you can use the debugging feature of the Arduino IDE 2.","title":"Arduino IDE 2 debugging"},{"location":"debugging/#compiling-the-sketch","text":"You must load the sketch into the editor and select a board as usual. If you want to debug an Arduino UNO board, choose ATmega328 from the Minicore in the Tools menu. Before clicking the Verify button in the upper left corner, choose Optimize for Debugging in the Sketch menu. This is necessary so that the compiler optimizes the code in a way that makes debugging straightforward. Otherwise, the compiler may rearrange source code lines, and one will get confused when single-stepping through the code.","title":"Compiling the sketch"},{"location":"debugging/#debugging_1","text":"After having verified the sketch (which also compiled it), it is time to start debugging by clicking on the debug button in the top row. This will start the debug server, which will notice that the MCU is not yet in debugWIRE mode and ask you to power-cycle the target board by displaying a message to that effect. Instead of the message shown in the following screenshot, it may happen that a warning \"No hardware debugger discovered\" is shown. The reason may be that the Arduino IDE 2 reserved the debugger's serial line for the Serial Monitor . Close the Serial Monitor console and try again. As mentioned in Section 2, power cycling is only necessary once. The next time you start a debugging session, the MCU will already be in debugWIRE mode, and the debugger will not stop at this point. After power-cycling the target, the debugger starts. Eventually, execution is stopped in line 35 of the Arduino internal file main.cpp at an initial internal breakpoint, indicated by the yellow triangle left of the line in the following screenshot. It might take a while before we reach that point because the debugger must also load the program. After stopping, the IDE rearranges the layout, showing the debugging panes on the left and the sketch on the right. It will also switch from showing the gdb-server console to the Debug Console , which shows the output of the GDB debugger. Now is a good time to familiarize yourself with the window's layout. The source code is on the right side. Below that is a console window, and to the left are the debug panes. If you want to set a breakpoint, you can do that by clicking to the left of the line numbers. Such breakpoints are displayed as red dots, such as those left of lines 8 and 13. The debugging panes are organized as follows. Pane A contains the debug controls. From left to right: Reset ting the device Continue execution or pause Step over : execute one source line Step into : execute stepping into the function, if in this line one is called Step out : finish the current function and stop after the line where it was called Restart : Same as Reset Stop : Terminate debugging Pane B shows the active threads, but there is just one in our case. Pane C displays the call stack starting from the bottom, i.e., the current frame is the topmost. Pane D displays variable values. Unfortunately, global variables are not shown. Pane E can be populated with watch expressions. Finally, in pane F, the active breakpoints are listed. The panes below are useless in our case. Some more information about debugging can be found in the Arduino debugging tutorial .","title":"Debugging"},{"location":"debugging/#some-pro-tips","text":"If you want to switch from the dw-link debugger to a professional hardware debugger, e.g., MPLAP SNAP or Atmel-ICE , these debuggers can be used as a drop-in replacement! So you do not have to change anything in the hardware or software configuration. And the SNAP is really cheap these days! The I/O registers are displayed in the CORTEX PERIPHERALS debugger pane. There, you can also change single register values. Global variables are, by default, not displayed. However, you can set a watch expression in the Watch pane to display a global variable's value. Or you can disable link time optimization (LTO) in the Tools menu. Then all global variables show up, except for one (which is an error of the IDE). If you select the Debug Console, you can type GDB commands in the bottom line. This can be useful for changing the value of global variables using the GDB command set var <varname>=<value> . This can also be used to disable the debugWIRE mode using the command monitor debugwire disable . The following section describes more monitor commands.","title":"Some Pro Tips"},{"location":"debugging/#monitor-commands","text":"Command Action monitor atexit [ stayindebugwire | leavedebugwire ] When specifying leavedebugwire , then debugWIRE mode will be left when exiting the debugger. This is useful when dealing with embedded debuggers such as the Xplained Mini boards. The default is stayindebugwire , i.e., debugWIREmode will not be left when exiting the debugger. monitor breakpoints [ all | software | hardware ] Restricts the kind of breakpoints that can be used. Either all types are permitted, only software breakpoints are allowed, or only hardware breakpoints can be used. Using all kinds is the default. monitor caching [ enable | disable ] This command is not implemented in dw-link. monitor debugwire [ enable | disable ] DebugWIRE mode will be enable d or disable d. When enabling it, the MCU will be reset, and you may be asked to power-cycle the target. After disabling debugWIRE mode, one has to exit the debugger. Afterward, the MCU can be programmed again using SPI programming. monitor erasebeforeload [ enable | disable ] This command is not implemented in dw-link because there is no way to erase the flash memory in debugWIRE mode. monitor help Display help text. monitor info Display information about the target and the state of the debugger. monitor load [ readbeforewrite | writeonly | onlycache ] When loading an executable, either each flash page is compared with the content to be loaded, and flashing is skipped if the content is already there ( readbeforewrite ), or each flash page is written without reading the current contents beforehand ( writeonly ). The first option is the default option for debugWIRE targets. For JTAG targets, the overhead of checking whether the page content is identical is so high that the writeonly option is the default. The third option ( onlycache ) will disable loading code into flash memory, but only fill the cache of PyAvrOCD. This is useful when one knows that the code is already loaded and one wants to avoid the overhead of reading flash memory content. monitor onlywhenloaded [ enable | disable ] Execution is only possible when a load command was previously executed, which is the default. If you want to start execution without loading an executable first, you need to disable this mode. monitor rangestepping [ enable | disable ] The GDB range-stepping command is supported or disabled. The default is that it is enable d. monitor reset Resets the MCU. monitor singlestep [ safe | interruptible ] Single-stepping can be performed in a safe way, where single steps are shielded against interrupts. Otherwise, a single step can lead to a jump into the interrupt dispatch table. The safe option is the default. monitor timer [ run | freeze ] Timers can either be frozen when execution is stopped, or they can run freely. The latter option is helpful when PWM output is crucial, and it is the default. monitor verify [ enable | disable ] Verify flash after loading each flash page. The default setting is for this option to be enable d. monitor version Show version of the gdbserver. All commands can, as usual, be abbreviated. For example, mo d e is equivalent to monitor debugwire enable . If you use a command without an argument, the current setting is printed. All state-changing commands (except debugwire ) can also be specified as command-line options when invoking PyAvrOCD, e.g., --verify disable .","title":"Monitor commands"},{"location":"debugging/#restoring-an-uno-to-its-native-state","text":"When you want to restore the target so that it behaves again like an ordinary UNO after a debugging session, you have two options: you can restore it as a MiniCore 328P board or as an original UNO board. The former one is the more attractive alternative in my eyes. Just check out the pages about MiniCore . Further, the command Burn Bootloader does apparently not work so well with some programmers or debuggers when doing it for the Uno setting. However, the dw-link built-in programmer has no problems. In order to restore your board, you need to do the following steps: You need the target board to exit the debugWIRE mode. This could be done by typing monitor debugwire disable into the debugger just before exiting. Or it will be done automagically using the built-in programmer mentioned in the following step. Now you have to flash the bootloader. Since version 2.2.0, the hardware debugger can also act as a programmer! This means that you leave the whole hardware setup as it was. However, you can, of course, use any other ISP programmer. Select Arduino UNO or the ATmega328 board as the target board in the Tools menu, select AVR ISP as the Programmer, choose the correct serial port, and use Burn Bootloader from the Tools menu. This will revert the MCU to its normal state (if it is still in debugWARE state) and will restore the fuses, the bootloader, and the lock bits to their original state. Reestablish the RESET EN connection by putting a solder blob on the connection or soldering pins to the connections that can be shortened using a jumper, as shown in the following picture. It does not look pretty, but it does its job. After that, your UNO is as good as new. Note that in the future, code uploading should be done by choosing the type of board you used when executing the Burn Bootloader command.","title":"Restoring an Uno to its native state"},{"location":"history/","text":"Revision history V 1.1 Initial version V 1.2 Changed pin mapping. The default is now to use ISP pins on the debugger so that a simple ISP cable with broken out RESET line is sufficient. System LED is pin D7, GND for the system LED is provided at pin D6. In order to use the pin mapping for shields/adapters, one has to tie SNSGND to ground, whereby the pin number of SNSGND depends on the Arduino board dw-link is compiled for (see mapping described in Section 8.3.3 ). Added wording to recommend optimization level -O0 instead of -Og, because otherwise assignments to local variables will not work. Single-stepping works now with -Og after dw-link hides all inserted BREAK instructions. V 1.3 Removed Arduino Mega boards from the set of boards that can be used as hardware debuggers V 1.4 New error messages System LED with fewer modes Some screen shots added to PlatformIO description V 1.5 New error message (126) default DW speed is now 250 kbps V 1.6 New example: Debugging Uno board as target V 1.7 Changes in 8.7 Section 9, Problem 'vMustReplyEmpty': timeout - explanation of what problems I encountered Section 5.1-5.3 have been reworked, in particular concerning ATTinyCore 2.0.0 and the new Python script for extending the boards.txt files. V 1.8 New help command for monitor commands in 5.7 V 1.9 Additional trouble shooting help when lock bits are set V 1.10 Pointed out in Section 4.2 that when debugging an Uno the first time you try to debug it, you need to erase the chip in order to clear the lock bits. Added similar wording under trouble shooting V 1.11 fixed some small inconsistencies V 2.0 Removed \u201elock bit\u201c error Added explanation that lock bits are automatically removed by erasing the entire chip Added extra part how to restore UNO functionality Restructured Introduction Removed instructions how to modify board and platform files. Now the board definition files are downloaded from my fork. Added section 8.11 More explanation how to start a debugging session using the Arduino IDE Reorganized and simplified as much as possible Corrected wrong placement in the table about the connections between UNO and ATtiny85 new monitor command: lasterror deleted monitor commands: eraseflash, serial added comment about dark system LED changed Section 7 in order to describe the V2.0 design have thrown out ATtiny13 since it behaves strangely added that disabling debugWIRE is now done automatically added dw-server.py added description of Gede added description of new hardware version added that dw-link is now also an ISP programmer simplified recovery for UNO V 3.0 Redesign of monitor commands; most of them now take an argument Disabling automatic mode switching (Section 2) Lowest frequency is now 4kHz (Section 8.7) Number of breakpoints reduced from 33 to 25 because of stability problems (when debugging was on) New dw-link probe Debugging UNO with an active serial connection to the host Added problem that stopping at a function might display the location of the inlined function V 4.0 Integration of Arduino IDE 2 New fatal error: Wrong MCU type (caused by monitor mcu command) Renamed fatal error 3 The boards manager URLs have changed: a suffix _plus_Debug has been added to the core name. Simplified platformio.ini Corrected statement about the meaning of BREAK when the debugger is not active monitor mcu command listed Description of how to use the AutoDW jumper added Added a section on how to restore an UNO Added a problem section on when the hardware debugger becomes unresponsive Added notes that you cannot debug the UNO, but need to select ATmega328 Added notes about the target board and potentially using external powering Edited the problem description for locked up hardware debugger/serial line New fatal error: capacitive load on the reset line Introduced subsections in the problem section Added monitor runtimers command in table Added paragraph in problem section how to use monitor runtimers New section 3.1 about choosing between external powering and powering using the hardware debugger. Changed some section titles in order to make compatible with the TOC generator Removed monitor oscillator . This is actually something quite dangerous, because it can brick the chip. Added new 'S' switch for monitor breakpoint Added note that the debugger might recognize capacitive load on the RESET line. V 5.0 No more powering through a data pin, i.e., VSUP on pin D9! The only way automatic power-cycling happens now is when the dw-link probe shield is installed and the command monitor debugwire e is used. The only way to enter dW mode is now the command monitor debugwire enable . The only way to leave is the command monitor debugwire disable (or using the appropiate debugger and issue a Burn Bootloader command). Changed and extended monitor commands in order to make it compatible with dw-gdbserver Thrown out Sections 5 & 7. Will be handeled in dw-gdbserver setup instructions New fatal error 113: Error verifying flashed page while loading program ATtiny13 support V 5.1 Completely reworked the manual to put it into the MkDocs format. V 5.2 Adapted to new package indices in the quickstart and installation sections","title":"Document revision history"},{"location":"history/#revision-history","text":"","title":"Revision history"},{"location":"history/#v-11","text":"Initial version","title":"V 1.1"},{"location":"history/#v-12","text":"Changed pin mapping. The default is now to use ISP pins on the debugger so that a simple ISP cable with broken out RESET line is sufficient. System LED is pin D7, GND for the system LED is provided at pin D6. In order to use the pin mapping for shields/adapters, one has to tie SNSGND to ground, whereby the pin number of SNSGND depends on the Arduino board dw-link is compiled for (see mapping described in Section 8.3.3 ). Added wording to recommend optimization level -O0 instead of -Og, because otherwise assignments to local variables will not work. Single-stepping works now with -Og after dw-link hides all inserted BREAK instructions.","title":"V 1.2"},{"location":"history/#v-13","text":"Removed Arduino Mega boards from the set of boards that can be used as hardware debuggers","title":"V 1.3"},{"location":"history/#v-14","text":"New error messages System LED with fewer modes Some screen shots added to PlatformIO description","title":"V 1.4"},{"location":"history/#v-15","text":"New error message (126) default DW speed is now 250 kbps","title":"V 1.5"},{"location":"history/#v-16","text":"New example: Debugging Uno board as target","title":"V 1.6"},{"location":"history/#v-17","text":"Changes in 8.7 Section 9, Problem 'vMustReplyEmpty': timeout - explanation of what problems I encountered Section 5.1-5.3 have been reworked, in particular concerning ATTinyCore 2.0.0 and the new Python script for extending the boards.txt files.","title":"V 1.7"},{"location":"history/#v-18","text":"New help command for monitor commands in 5.7","title":"V 1.8"},{"location":"history/#v-19","text":"Additional trouble shooting help when lock bits are set","title":"V 1.9"},{"location":"history/#v-110","text":"Pointed out in Section 4.2 that when debugging an Uno the first time you try to debug it, you need to erase the chip in order to clear the lock bits. Added similar wording under trouble shooting","title":"V 1.10"},{"location":"history/#v-111","text":"fixed some small inconsistencies","title":"V 1.11"},{"location":"history/#v-20","text":"Removed \u201elock bit\u201c error Added explanation that lock bits are automatically removed by erasing the entire chip Added extra part how to restore UNO functionality Restructured Introduction Removed instructions how to modify board and platform files. Now the board definition files are downloaded from my fork. Added section 8.11 More explanation how to start a debugging session using the Arduino IDE Reorganized and simplified as much as possible Corrected wrong placement in the table about the connections between UNO and ATtiny85 new monitor command: lasterror deleted monitor commands: eraseflash, serial added comment about dark system LED changed Section 7 in order to describe the V2.0 design have thrown out ATtiny13 since it behaves strangely added that disabling debugWIRE is now done automatically added dw-server.py added description of Gede added description of new hardware version added that dw-link is now also an ISP programmer simplified recovery for UNO","title":"V 2.0"},{"location":"history/#v-30","text":"Redesign of monitor commands; most of them now take an argument Disabling automatic mode switching (Section 2) Lowest frequency is now 4kHz (Section 8.7) Number of breakpoints reduced from 33 to 25 because of stability problems (when debugging was on) New dw-link probe Debugging UNO with an active serial connection to the host Added problem that stopping at a function might display the location of the inlined function","title":"V 3.0"},{"location":"history/#v-40","text":"Integration of Arduino IDE 2 New fatal error: Wrong MCU type (caused by monitor mcu command) Renamed fatal error 3 The boards manager URLs have changed: a suffix _plus_Debug has been added to the core name. Simplified platformio.ini Corrected statement about the meaning of BREAK when the debugger is not active monitor mcu command listed Description of how to use the AutoDW jumper added Added a section on how to restore an UNO Added a problem section on when the hardware debugger becomes unresponsive Added notes that you cannot debug the UNO, but need to select ATmega328 Added notes about the target board and potentially using external powering Edited the problem description for locked up hardware debugger/serial line New fatal error: capacitive load on the reset line Introduced subsections in the problem section Added monitor runtimers command in table Added paragraph in problem section how to use monitor runtimers New section 3.1 about choosing between external powering and powering using the hardware debugger. Changed some section titles in order to make compatible with the TOC generator Removed monitor oscillator . This is actually something quite dangerous, because it can brick the chip. Added new 'S' switch for monitor breakpoint Added note that the debugger might recognize capacitive load on the RESET line.","title":"V 4.0"},{"location":"history/#v-50","text":"No more powering through a data pin, i.e., VSUP on pin D9! The only way automatic power-cycling happens now is when the dw-link probe shield is installed and the command monitor debugwire e is used. The only way to enter dW mode is now the command monitor debugwire enable . The only way to leave is the command monitor debugwire disable (or using the appropiate debugger and issue a Burn Bootloader command). Changed and extended monitor commands in order to make it compatible with dw-gdbserver Thrown out Sections 5 & 7. Will be handeled in dw-gdbserver setup instructions New fatal error 113: Error verifying flashed page while loading program ATtiny13 support","title":"V 5.0"},{"location":"history/#v-51","text":"Completely reworked the manual to put it into the MkDocs format.","title":"V 5.1"},{"location":"history/#v-52","text":"Adapted to new package indices in the quickstart and installation sections","title":"V 5.2"},{"location":"installation/","text":"Installation of firmware and software environment There are only a few steps necessary for installing the dw-link firmware on the hardware debugger. Setting up the software environment is also quite simple, if you either opt for CLI debugging with AVR-GDB or the Arduino IDE 2. For other options, I refer to PyAvrOCD . Firmware installation You need to install the dw-link firmware on an UNO. Connect the UNO to your computer and upload the firmware. The simplest way is to download an uploader from the Release assets of the GitHub repo. This should fit your architecture, e.g., dw-uploader-windows-intel64 for Windows. Under Linux and macOS , open a terminal window, go to the download folder, and set the executable permission using chmod +x . Afterward, execute the program. Under Windows , it is enough to start the program after downloading by double-clicking on it. Alternatively, you can download or clone the dw-link repository and then compile and upload the dw-link Arduino sketch. You can also use PlatformIO for that purpose, because the repo is already in the right format. Setting up the debugging software Finally, you need to install the debugging software on the host. Installing AVR-GDB If you want to perform debugging using a command-line interface, you only need to install avr-gdb, which is most probably already installed on your host anyway. On Linux, the package manager of your choice will solve the problem. Note that the corresponding package is named gdb-avr ! On macOS, use Homebrew . After having installed Homebrew, type: xcode-select --install brew tap osx-cross/avr brew install avr-gdb Under Windows, you can download a version from Zak's avr-gcc-build repository. Installing board packages for the Arduino IDE 2 Open the Preferences dialog of the Arduino IDE and paste the following three URLs into the list of Additional boards manager URLs : https://downloads.pyavrocd.io/package_debug_enabled_index.json https://MCUdude.github.io/MicroCore/package_MCUdude_MicroCore_index.json https://MCUdude.github.io/MiniCore/package_MCUdude_MiniCore_index.json The first package index will make the following board packages known to the IDE: Atmel AVR Xplained-minis (Debug enabled) , which is a new core only for the three Atmega328/168 Xplained mini boards. It is based on MiniCore (see below), but is heavily tailored towards these development boards. Since these boards have a hardware debugger on board, dw-link is not needed here. ATTinyCore (Debug enabled) , which is a fork of ATTinyCore-2.0.0 extended to allow for debugging. The remaining two package indices make the MicroCore (ATtin13(a)) and MiniCore (ATmegaX8) known to the IDE. These cores are already debug-enabled. Then, you need to start the Boards Manager , which you find under Tools --> Board . Install any of the above cores you want. Note that the packages include tools that might be incompatible with older OS versions. If you encounter problems when starting the debugging software, consult the troubleshooting section on startup problems .","title":"Installation"},{"location":"installation/#installation-of-firmware-and-software-environment","text":"There are only a few steps necessary for installing the dw-link firmware on the hardware debugger. Setting up the software environment is also quite simple, if you either opt for CLI debugging with AVR-GDB or the Arduino IDE 2. For other options, I refer to PyAvrOCD .","title":"Installation of firmware and software environment"},{"location":"installation/#firmware-installation","text":"You need to install the dw-link firmware on an UNO. Connect the UNO to your computer and upload the firmware. The simplest way is to download an uploader from the Release assets of the GitHub repo. This should fit your architecture, e.g., dw-uploader-windows-intel64 for Windows. Under Linux and macOS , open a terminal window, go to the download folder, and set the executable permission using chmod +x . Afterward, execute the program. Under Windows , it is enough to start the program after downloading by double-clicking on it. Alternatively, you can download or clone the dw-link repository and then compile and upload the dw-link Arduino sketch. You can also use PlatformIO for that purpose, because the repo is already in the right format.","title":"Firmware installation"},{"location":"installation/#setting-up-the-debugging-software","text":"Finally, you need to install the debugging software on the host.","title":"Setting up the debugging software"},{"location":"installation/#installing-avr-gdb","text":"If you want to perform debugging using a command-line interface, you only need to install avr-gdb, which is most probably already installed on your host anyway. On Linux, the package manager of your choice will solve the problem. Note that the corresponding package is named gdb-avr ! On macOS, use Homebrew . After having installed Homebrew, type: xcode-select --install brew tap osx-cross/avr brew install avr-gdb Under Windows, you can download a version from Zak's avr-gcc-build repository.","title":"Installing AVR-GDB"},{"location":"installation/#installing-board-packages-for-the-arduino-ide-2","text":"Open the Preferences dialog of the Arduino IDE and paste the following three URLs into the list of Additional boards manager URLs : https://downloads.pyavrocd.io/package_debug_enabled_index.json https://MCUdude.github.io/MicroCore/package_MCUdude_MicroCore_index.json https://MCUdude.github.io/MiniCore/package_MCUdude_MiniCore_index.json The first package index will make the following board packages known to the IDE: Atmel AVR Xplained-minis (Debug enabled) , which is a new core only for the three Atmega328/168 Xplained mini boards. It is based on MiniCore (see below), but is heavily tailored towards these development boards. Since these boards have a hardware debugger on board, dw-link is not needed here. ATTinyCore (Debug enabled) , which is a fork of ATTinyCore-2.0.0 extended to allow for debugging. The remaining two package indices make the MicroCore (ATtin13(a)) and MiniCore (ATmegaX8) known to the IDE. These cores are already debug-enabled. Then, you need to start the Boards Manager , which you find under Tools --> Board . Install any of the above cores you want. Note that the packages include tools that might be incompatible with older OS versions. If you encounter problems when starting the debugging software, consult the troubleshooting section on startup problems .","title":"Installing board packages for the Arduino IDE 2"},{"location":"internal_errors/","text":"If the error number is less than 100, then it is a connection error. Try again, perhaps after disconnecting and reconnecting everything. Check wiring. If the error persists, try perhaps with a different MCU. Errors above 100 are serious internal debugger errors. If you have encountered such an internal debugger error, then please try to reproduce the problem and tell me how it happened. After a reset or a power cycle of the hardware debugger, everything usually works again. If not, you need to unplug everything and put it together again. Error # Meaning 1 Could not communicate by ISP; check wiring 2 Could not activate debugWIRE 3 MCU type is not supported 4 Lockbits could not be cleared 5 Lockbits are set but not managed by dw-link 6 BOOTRST fuse could not be cleared 7 MCU has a program counter with stuck-at-one bits 8 RESET line has a capacitive load 9 Target not powered or RESET shortened to GND 10 MCU type does not match 11 DWEN fuse could not be programmed 12 DWEN fuse is unprogrammed but not managed by dw-link 13 EESAVE fuse could not be changed 14 Unknown connection error 101 No free slot in breakpoint table 102 Packet length too large 103 Wrong memory type 104 Packet length is negative 105 Reset operation failed 106 Memory address in flash read operation does not point to page start 107 Could not complete flash read operation 108 Could not complete RAM read operation 109 Memory address in flash write operation does not point to page start 110 Could not complete flash page erase operation 111 Could not load data into the flash buffer for writing 112 Error when programming flash page from buffer 113 Error verifying flashed page while loading program 114 Assignment of hardware breakpoint is inconsistent 115 BREAK inserted by debugger at a point where a step or execute operation is required 116 Trying to read flash word at an uneven address 117 Error when single-stepping 118 A relevant breakpoint has disappeared 119 Input buffer overflow 120 Wrong fuse 121 Breakpoint update while flash programming is active 122 Timeout while reading from debugWIRE line 123 Timeout while reading general register 124 Timeout while reading IO register 125 Could not reenable RWW 126 Failure while reading from EEPROM 127 Bad interrupt 128 Inconsistent classification of opcodes in range-stepping","title":"Internal errors"},{"location":"intro/","text":"Background Before we start the excursion into the world of debugging, some background on the debugWIRE interface is provided, sketching the physical properties of the debugWIRE protocol. Then we survey other open-source approaches to debugging classic AVR MCUs . With that out of the way, we have a look at what we need on the hardware side. You need an Arduino UNO (or something equivalent) as the hardware debugger and a chip or board that understands debugWIRE , i.e., a classic ATtiny or an ATmegaX8. Then, you have to install the debugger firmware on the UNO and install a software debugging environment . If that is all done, you need to set up the hardware for a debugging session . If you have performed all the above steps, then the setup should look like as in the following picture. Your development machine, the host , is connected to the UNO acting as a hardware debugger over the usual USB connection. The two devices use the GDB remote serial protocol to communicate with each other. The hardware debugger in turn is connected to the target system , whereby the debugWIRE protocol is used for communication. The physical connection between the hardware debugger and the target, as described in the section about the hardware setup , is something that might need some enhancements. Instead of six jumper wires, you may want to have a more durable connection. This is covered in the part about a better hardware debugger . Finally, possible problems and troubleshooting is covered. And what do you with your hardware debugger once you have debugged all your programs and they work flawlessly? Since version 2.2.0, you can use dw-link also as an STK500 v1 ISP programmer. If you connect to dw-link with 19200 bps and start avrdude, then dw-link becomes an ISP programmer. The debugWIRE interface The basic idea of debugWIRE is that the RESET line is used as a communication line between the target system (the system you want to debug) and the hardware debugger, which in turn can then communicate with the development machine or host, which runs a debug program such as GDB. The idea of using only a single line that is not used otherwise is very cool because it does not waste any of the other pins for debugging purposes (as does, e.g., the JTAG interface ). However, using the RESET line as a communication channel means, of course, that one cannot use the RESET line to reset the MCU anymore. Furthermore, one cannot any longer use ISP programming to upload new firmware to the MCU or change the fuses of the MCU. With respect to the debugWIRE protocol there are basically three states your MCU could be in: The normal state in which the DWEN (debugWIRE enable) fuse is disabled. In this state, you can use ISP programming to change fuses and to upload programs. By enabling the DWEN fuse, one reaches the transitional state . The transitional state is the state in which the DWEN fuse is enabled. In this state, you could use ISP programming to disable the DWEN fuse again, to reach the normal state . By power-cycling (switching the target system off and on again), one reaches the debugWIRE state . The debugWIRE state is the state in which you can use the debugger to control the target system. If you want to return to the normal state , a particular debugWIRE command leads to the transitional state , from which one can reach the normal state using ordinary ISP programming by disabling the DWEN fuse. The hardware debugger will take care of bringing you from normal state to debugWIRE state when you type the command monitor debugwire enable . In fact, when using the Arduino IDE 2, this will be done in the background for you. After the hardware debugger has enabled the DWEN fuse, the system LED will flash in a particular pattern, which signals that you should power-cycle the target. Further, in the GDB debugger, a message will be shown that asks you to power-cycle the target system. If the hardware debugger powers the target, it will power-cycle automatically. This transition is only necessary once. The next time, when you start a debugging session, the target system is already in the debugWIRE state and nothing needs to be done. When you are done with debugging and you want to get the target system back into the normal state, you must type the command monitor debugwire disable just before exiting the debugger. Other debugging approaches for classic ATtinys and ATmegaX8s While dw-link is (unsurprisingly) one of my preferred open source solution for debugging classic tiny AVRs and ATmegaX8s, there are a number of other possible solutions. Bloom is not a hardware debugger, but it is a pretty extensive implementation of a gdbserver for almost all AVR MCUs using the Microchip hardware debuggers. The only drawback is that it runs only under Linux. Similarly, avarice is another such gdbserver, which covers even more hardware debuggers. Recently, I added another gdbserver to the mix, written for debugWIRE only: dw-gdbserver . This has been extended to cover also JTAG targets and will probably be work with UPDI targets in the not so distant future. Best of all, it provides a pass-through service for dw-link. There exists a software simulator called SIMAVR , and there is a GDB remote stub for some ATmegas, called avr_debug . Both are integrated into PlatformIO as debuggers. However, both tools come with a lot of restrictions, and using them is not the same as debugging on the hardware where your firmware should finally run. Based on RikusW's work on reverse engineering the debugWIRE protocol , you can find a few attempts at building debuggers using debugWIRE. First, there is an implementation called dwire-debug for host systems that uses only the serial line interface to talk with a target using the debugWIRE interface. This program implements GDB's remote serial protocol. Unfortunately, the particular way of turning a serial interface into a one-wire interface did not work for me on a Mac. This approach has been further developed, resulting in an interesting solution for debugging Arduino UNOs using a CH552 board . Then there is also an Arduino UNO-based hardware debugger called DebugWireDebuggerProgrammer . However, it does not provide an interface for GDB's remote serial protocol. On top of that, all these solutions allow only one breakpoint (the hardware breakpoint of debugWIRE). There exists an implementation similar to dwire-debug in Pascal called debugwire-gdb-bridge that appears to be more complete. In particular, it handles multiple breakpoints. However, I was not able to install it. That is probably based on the fact that my knowledge of Pascal is rusty and I have no experience with the Lazarus IDE. I took all of the above ideas (and some of the code) and put them together in order to come up with a cheap debugWIRE hardware debugger supporting GDB's remote serial protocol. Actually, it was a bit more than just throwing things together. I developed a new library for single-wire serial communication that is much more reliable and robust than the usually employed SoftwareSerial library. Further, I fixed a few loose ends in the existing implementations, sped up communication and flash programming, supported slow MCU clocks, implemented an interrupt-safe way of single-stepping , and spent a few nights debugging the debugger. And I tested the debugger on almost all MCUs supported by ATTinyCore , MicroCore , and MiniCore . Along the way, I also made a number of interesting discoveries .","title":"Background"},{"location":"intro/#background","text":"Before we start the excursion into the world of debugging, some background on the debugWIRE interface is provided, sketching the physical properties of the debugWIRE protocol. Then we survey other open-source approaches to debugging classic AVR MCUs . With that out of the way, we have a look at what we need on the hardware side. You need an Arduino UNO (or something equivalent) as the hardware debugger and a chip or board that understands debugWIRE , i.e., a classic ATtiny or an ATmegaX8. Then, you have to install the debugger firmware on the UNO and install a software debugging environment . If that is all done, you need to set up the hardware for a debugging session . If you have performed all the above steps, then the setup should look like as in the following picture. Your development machine, the host , is connected to the UNO acting as a hardware debugger over the usual USB connection. The two devices use the GDB remote serial protocol to communicate with each other. The hardware debugger in turn is connected to the target system , whereby the debugWIRE protocol is used for communication. The physical connection between the hardware debugger and the target, as described in the section about the hardware setup , is something that might need some enhancements. Instead of six jumper wires, you may want to have a more durable connection. This is covered in the part about a better hardware debugger . Finally, possible problems and troubleshooting is covered. And what do you with your hardware debugger once you have debugged all your programs and they work flawlessly? Since version 2.2.0, you can use dw-link also as an STK500 v1 ISP programmer. If you connect to dw-link with 19200 bps and start avrdude, then dw-link becomes an ISP programmer.","title":"Background"},{"location":"intro/#the-debugwire-interface","text":"The basic idea of debugWIRE is that the RESET line is used as a communication line between the target system (the system you want to debug) and the hardware debugger, which in turn can then communicate with the development machine or host, which runs a debug program such as GDB. The idea of using only a single line that is not used otherwise is very cool because it does not waste any of the other pins for debugging purposes (as does, e.g., the JTAG interface ). However, using the RESET line as a communication channel means, of course, that one cannot use the RESET line to reset the MCU anymore. Furthermore, one cannot any longer use ISP programming to upload new firmware to the MCU or change the fuses of the MCU. With respect to the debugWIRE protocol there are basically three states your MCU could be in: The normal state in which the DWEN (debugWIRE enable) fuse is disabled. In this state, you can use ISP programming to change fuses and to upload programs. By enabling the DWEN fuse, one reaches the transitional state . The transitional state is the state in which the DWEN fuse is enabled. In this state, you could use ISP programming to disable the DWEN fuse again, to reach the normal state . By power-cycling (switching the target system off and on again), one reaches the debugWIRE state . The debugWIRE state is the state in which you can use the debugger to control the target system. If you want to return to the normal state , a particular debugWIRE command leads to the transitional state , from which one can reach the normal state using ordinary ISP programming by disabling the DWEN fuse. The hardware debugger will take care of bringing you from normal state to debugWIRE state when you type the command monitor debugwire enable . In fact, when using the Arduino IDE 2, this will be done in the background for you. After the hardware debugger has enabled the DWEN fuse, the system LED will flash in a particular pattern, which signals that you should power-cycle the target. Further, in the GDB debugger, a message will be shown that asks you to power-cycle the target system. If the hardware debugger powers the target, it will power-cycle automatically. This transition is only necessary once. The next time, when you start a debugging session, the target system is already in the debugWIRE state and nothing needs to be done. When you are done with debugging and you want to get the target system back into the normal state, you must type the command monitor debugwire disable just before exiting the debugger.","title":"The debugWIRE interface"},{"location":"intro/#other-debugging-approaches-for-classic-attinys-and-atmegax8s","text":"While dw-link is (unsurprisingly) one of my preferred open source solution for debugging classic tiny AVRs and ATmegaX8s, there are a number of other possible solutions. Bloom is not a hardware debugger, but it is a pretty extensive implementation of a gdbserver for almost all AVR MCUs using the Microchip hardware debuggers. The only drawback is that it runs only under Linux. Similarly, avarice is another such gdbserver, which covers even more hardware debuggers. Recently, I added another gdbserver to the mix, written for debugWIRE only: dw-gdbserver . This has been extended to cover also JTAG targets and will probably be work with UPDI targets in the not so distant future. Best of all, it provides a pass-through service for dw-link. There exists a software simulator called SIMAVR , and there is a GDB remote stub for some ATmegas, called avr_debug . Both are integrated into PlatformIO as debuggers. However, both tools come with a lot of restrictions, and using them is not the same as debugging on the hardware where your firmware should finally run. Based on RikusW's work on reverse engineering the debugWIRE protocol , you can find a few attempts at building debuggers using debugWIRE. First, there is an implementation called dwire-debug for host systems that uses only the serial line interface to talk with a target using the debugWIRE interface. This program implements GDB's remote serial protocol. Unfortunately, the particular way of turning a serial interface into a one-wire interface did not work for me on a Mac. This approach has been further developed, resulting in an interesting solution for debugging Arduino UNOs using a CH552 board . Then there is also an Arduino UNO-based hardware debugger called DebugWireDebuggerProgrammer . However, it does not provide an interface for GDB's remote serial protocol. On top of that, all these solutions allow only one breakpoint (the hardware breakpoint of debugWIRE). There exists an implementation similar to dwire-debug in Pascal called debugwire-gdb-bridge that appears to be more complete. In particular, it handles multiple breakpoints. However, I was not able to install it. That is probably based on the fact that my knowledge of Pascal is rusty and I have no experience with the Lazarus IDE. I took all of the above ideas (and some of the code) and put them together in order to come up with a cheap debugWIRE hardware debugger supporting GDB's remote serial protocol. Actually, it was a bit more than just throwing things together. I developed a new library for single-wire serial communication that is much more reliable and robust than the usually employed SoftwareSerial library. Further, I fixed a few loose ends in the existing implementations, sped up communication and flash programming, supported slow MCU clocks, implemented an interrupt-safe way of single-stepping , and spent a few nights debugging the debugger. And I tested the debugger on almost all MCUs supported by ATTinyCore , MicroCore , and MiniCore . Along the way, I also made a number of interesting discoveries .","title":"Other debugging approaches for classic ATtinys and ATmegaX8s"},{"location":"license-link/","text":"GNU GENERAL PUBLIC LICENSE Version 3, 29 June 2007 Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/> Everyone is permitted to copy and distribute verbatim copies of this license document, but changing it is not allowed. Preamble The GNU General Public License is a free, copyleft license for software and other kinds of works. The licenses for most software and other practical works are designed to take away your freedom to share and change the works. By contrast, the GNU General Public License is intended to guarantee your freedom to share and change all versions of a program--to make sure it remains free software for all its users. We, the Free Software Foundation, use the GNU General Public License for most of our software; it applies also to any other work released this way by its authors. You can apply it to your programs, too. When we speak of free software, we are referring to freedom, not price. Our General Public Licenses are designed to make sure that you have the freedom to distribute copies of free software (and charge for them if you wish), that you receive source code or can get it if you want it, that you can change the software or use pieces of it in new free programs, and that you know you can do these things. To protect your rights, we need to prevent others from denying you these rights or asking you to surrender the rights. Therefore, you have certain responsibilities if you distribute copies of the software, or if you modify it: responsibilities to respect the freedom of others. For example, if you distribute copies of such a program, whether gratis or for a fee, you must pass on to the recipients the same freedoms that you received. You must make sure that they, too, receive or can get the source code. And you must show them these terms so they know their rights. Developers that use the GNU GPL protect your rights with two steps: (1) assert copyright on the software, and (2) offer you this License giving you legal permission to copy, distribute and/or modify it. For the developers' and authors' protection, the GPL clearly explains that there is no warranty for this free software. For both users' and authors' sake, the GPL requires that modified versions be marked as changed, so that their problems will not be attributed erroneously to authors of previous versions. Some devices are designed to deny users access to install or run modified versions of the software inside them, although the manufacturer can do so. This is fundamentally incompatible with the aim of protecting users' freedom to change the software. The systematic pattern of such abuse occurs in the area of products for individuals to use, which is precisely where it is most unacceptable. Therefore, we have designed this version of the GPL to prohibit the practice for those products. If such problems arise substantially in other domains, we stand ready to extend this provision to those domains in future versions of the GPL, as needed to protect the freedom of users. Finally, every program is threatened constantly by software patents. States should not allow patents to restrict development and use of software on general-purpose computers, but in those that do, we wish to avoid the special danger that patents applied to a free program could make it effectively proprietary. To prevent this, the GPL assures that patents cannot be used to render the program non-free. The precise terms and conditions for copying, distribution and modification follow. TERMS AND CONDITIONS 0. Definitions. \"This License\" refers to version 3 of the GNU General Public License. \"Copyright\" also means copyright-like laws that apply to other kinds of works, such as semiconductor masks. \"The Program\" refers to any copyrightable work licensed under this License. Each licensee is addressed as \"you\". \"Licensees\" and \"recipients\" may be individuals or organizations. To \"modify\" a work means to copy from or adapt all or part of the work in a fashion requiring copyright permission, other than the making of an exact copy. The resulting work is called a \"modified version\" of the earlier work or a work \"based on\" the earlier work. A \"covered work\" means either the unmodified Program or a work based on the Program. To \"propagate\" a work means to do anything with it that, without permission, would make you directly or secondarily liable for infringement under applicable copyright law, except executing it on a computer or modifying a private copy. Propagation includes copying, distribution (with or without modification), making available to the public, and in some countries other activities as well. To \"convey\" a work means any kind of propagation that enables other parties to make or receive copies. Mere interaction with a user through a computer network, with no transfer of a copy, is not conveying. An interactive user interface displays \"Appropriate Legal Notices\" to the extent that it includes a convenient and prominently visible feature that (1) displays an appropriate copyright notice, and (2) tells the user that there is no warranty for the work (except to the extent that warranties are provided), that licensees may convey the work under this License, and how to view a copy of this License. If the interface presents a list of user commands or options, such as a menu, a prominent item in the list meets this criterion. 1. Source Code. The \"source code\" for a work means the preferred form of the work for making modifications to it. \"Object code\" means any non-source form of a work. A \"Standard Interface\" means an interface that either is an official standard defined by a recognized standards body, or, in the case of interfaces specified for a particular programming language, one that is widely used among developers working in that language. The \"System Libraries\" of an executable work include anything, other than the work as a whole, that (a) is included in the normal form of packaging a Major Component, but which is not part of that Major Component, and (b) serves only to enable use of the work with that Major Component, or to implement a Standard Interface for which an implementation is available to the public in source code form. A \"Major Component\", in this context, means a major essential component (kernel, window system, and so on) of the specific operating system (if any) on which the executable work runs, or a compiler used to produce the work, or an object code interpreter used to run it. The \"Corresponding Source\" for a work in object code form means all the source code needed to generate, install, and (for an executable work) run the object code and to modify the work, including scripts to control those activities. However, it does not include the work's System Libraries, or general-purpose tools or generally available free programs which are used unmodified in performing those activities but which are not part of the work. For example, Corresponding Source includes interface definition files associated with source files for the work, and the source code for shared libraries and dynamically linked subprograms that the work is specifically designed to require, such as by intimate data communication or control flow between those subprograms and other parts of the work. The Corresponding Source need not include anything that users can regenerate automatically from other parts of the Corresponding Source. The Corresponding Source for a work in source code form is that same work. 2. Basic Permissions. All rights granted under this License are granted for the term of copyright on the Program, and are irrevocable provided the stated conditions are met. This License explicitly affirms your unlimited permission to run the unmodified Program. The output from running a covered work is covered by this License only if the output, given its content, constitutes a covered work. This License acknowledges your rights of fair use or other equivalent, as provided by copyright law. You may make, run and propagate covered works that you do not convey, without conditions so long as your license otherwise remains in force. You may convey covered works to others for the sole purpose of having them make modifications exclusively for you, or provide you with facilities for running those works, provided that you comply with the terms of this License in conveying all material for which you do not control copyright. Those thus making or running the covered works for you must do so exclusively on your behalf, under your direction and control, on terms that prohibit them from making any copies of your copyrighted material outside their relationship with you. Conveying under any other circumstances is permitted solely under the conditions stated below. Sublicensing is not allowed; section 10 makes it unnecessary. 3. Protecting Users' Legal Rights From Anti-Circumvention Law. No covered work shall be deemed part of an effective technological measure under any applicable law fulfilling obligations under article 11 of the WIPO copyright treaty adopted on 20 December 1996, or similar laws prohibiting or restricting circumvention of such measures. When you convey a covered work, you waive any legal power to forbid circumvention of technological measures to the extent such circumvention is effected by exercising rights under this License with respect to the covered work, and you disclaim any intention to limit operation or modification of the work as a means of enforcing, against the work's users, your or third parties' legal rights to forbid circumvention of technological measures. 4. Conveying Verbatim Copies. You may convey verbatim copies of the Program's source code as you receive it, in any medium, provided that you conspicuously and appropriately publish on each copy an appropriate copyright notice; keep intact all notices stating that this License and any non-permissive terms added in accord with section 7 apply to the code; keep intact all notices of the absence of any warranty; and give all recipients a copy of this License along with the Program. You may charge any price or no price for each copy that you convey, and you may offer support or warranty protection for a fee. 5. Conveying Modified Source Versions. You may convey a work based on the Program, or the modifications to produce it from the Program, in the form of source code under the terms of section 4, provided that you also meet all of these conditions: a) The work must carry prominent notices stating that you modified it, and giving a relevant date. b) The work must carry prominent notices stating that it is released under this License and any conditions added under section 7. This requirement modifies the requirement in section 4 to \"keep intact all notices\". c) You must license the entire work, as a whole, under this License to anyone who comes into possession of a copy. This License will therefore apply, along with any applicable section 7 additional terms, to the whole of the work, and all its parts, regardless of how they are packaged. This License gives no permission to license the work in any other way, but it does not invalidate such permission if you have separately received it. d) If the work has interactive user interfaces, each must display Appropriate Legal Notices; however, if the Program has interactive interfaces that do not display Appropriate Legal Notices, your work need not make them do so. A compilation of a covered work with other separate and independent works, which are not by their nature extensions of the covered work, and which are not combined with it such as to form a larger program, in or on a volume of a storage or distribution medium, is called an \"aggregate\" if the compilation and its resulting copyright are not used to limit the access or legal rights of the compilation's users beyond what the individual works permit. Inclusion of a covered work in an aggregate does not cause this License to apply to the other parts of the aggregate. 6. Conveying Non-Source Forms. You may convey a covered work in object code form under the terms of sections 4 and 5, provided that you also convey the machine-readable Corresponding Source under the terms of this License, in one of these ways: a) Convey the object code in, or embodied in, a physical product (including a physical distribution medium), accompanied by the Corresponding Source fixed on a durable physical medium customarily used for software interchange. b) Convey the object code in, or embodied in, a physical product (including a physical distribution medium), accompanied by a written offer, valid for at least three years and valid for as long as you offer spare parts or customer support for that product model, to give anyone who possesses the object code either (1) a copy of the Corresponding Source for all the software in the product that is covered by this License, on a durable physical medium customarily used for software interchange, for a price no more than your reasonable cost of physically performing this conveying of source, or (2) access to copy the Corresponding Source from a network server at no charge. c) Convey individual copies of the object code with a copy of the written offer to provide the Corresponding Source. This alternative is allowed only occasionally and noncommercially, and only if you received the object code with such an offer, in accord with subsection 6b. d) Convey the object code by offering access from a designated place (gratis or for a charge), and offer equivalent access to the Corresponding Source in the same way through the same place at no further charge. You need not require recipients to copy the Corresponding Source along with the object code. If the place to copy the object code is a network server, the Corresponding Source may be on a different server (operated by you or a third party) that supports equivalent copying facilities, provided you maintain clear directions next to the object code saying where to find the Corresponding Source. Regardless of what server hosts the Corresponding Source, you remain obligated to ensure that it is available for as long as needed to satisfy these requirements. e) Convey the object code using peer-to-peer transmission, provided you inform other peers where the object code and Corresponding Source of the work are being offered to the general public at no charge under subsection 6d. A separable portion of the object code, whose source code is excluded from the Corresponding Source as a System Library, need not be included in conveying the object code work. A \"User Product\" is either (1) a \"consumer product\", which means any tangible personal property which is normally used for personal, family, or household purposes, or (2) anything designed or sold for incorporation into a dwelling. In determining whether a product is a consumer product, doubtful cases shall be resolved in favor of coverage. For a particular product received by a particular user, \"normally used\" refers to a typical or common use of that class of product, regardless of the status of the particular user or of the way in which the particular user actually uses, or expects or is expected to use, the product. A product is a consumer product regardless of whether the product has substantial commercial, industrial or non-consumer uses, unless such uses represent the only significant mode of use of the product. \"Installation Information\" for a User Product means any methods, procedures, authorization keys, or other information required to install and execute modified versions of a covered work in that User Product from a modified version of its Corresponding Source. The information must suffice to ensure that the continued functioning of the modified object code is in no case prevented or interfered with solely because modification has been made. If you convey an object code work under this section in, or with, or specifically for use in, a User Product, and the conveying occurs as part of a transaction in which the right of possession and use of the User Product is transferred to the recipient in perpetuity or for a fixed term (regardless of how the transaction is characterized), the Corresponding Source conveyed under this section must be accompanied by the Installation Information. But this requirement does not apply if neither you nor any third party retains the ability to install modified object code on the User Product (for example, the work has been installed in ROM). The requirement to provide Installation Information does not include a requirement to continue to provide support service, warranty, or updates for a work that has been modified or installed by the recipient, or for the User Product in which it has been modified or installed. Access to a network may be denied when the modification itself materially and adversely affects the operation of the network or violates the rules and protocols for communication across the network. Corresponding Source conveyed, and Installation Information provided, in accord with this section must be in a format that is publicly documented (and with an implementation available to the public in source code form), and must require no special password or key for unpacking, reading or copying. 7. Additional Terms. \"Additional permissions\" are terms that supplement the terms of this License by making exceptions from one or more of its conditions. Additional permissions that are applicable to the entire Program shall be treated as though they were included in this License, to the extent that they are valid under applicable law. If additional permissions apply only to part of the Program, that part may be used separately under those permissions, but the entire Program remains governed by this License without regard to the additional permissions. When you convey a copy of a covered work, you may at your option remove any additional permissions from that copy, or from any part of it. (Additional permissions may be written to require their own removal in certain cases when you modify the work.) You may place additional permissions on material, added by you to a covered work, for which you have or can give appropriate copyright permission. Notwithstanding any other provision of this License, for material you add to a covered work, you may (if authorized by the copyright holders of that material) supplement the terms of this License with terms: a) Disclaiming warranty or limiting liability differently from the terms of sections 15 and 16 of this License; or b) Requiring preservation of specified reasonable legal notices or author attributions in that material or in the Appropriate Legal Notices displayed by works containing it; or c) Prohibiting misrepresentation of the origin of that material, or requiring that modified versions of such material be marked in reasonable ways as different from the original version; or d) Limiting the use for publicity purposes of names of licensors or authors of the material; or e) Declining to grant rights under trademark law for use of some trade names, trademarks, or service marks; or f) Requiring indemnification of licensors and authors of that material by anyone who conveys the material (or modified versions of it) with contractual assumptions of liability to the recipient, for any liability that these contractual assumptions directly impose on those licensors and authors. All other non-permissive additional terms are considered \"further restrictions\" within the meaning of section 10. If the Program as you received it, or any part of it, contains a notice stating that it is governed by this License along with a term that is a further restriction, you may remove that term. If a license document contains a further restriction but permits relicensing or conveying under this License, you may add to a covered work material governed by the terms of that license document, provided that the further restriction does not survive such relicensing or conveying. If you add terms to a covered work in accord with this section, you must place, in the relevant source files, a statement of the additional terms that apply to those files, or a notice indicating where to find the applicable terms. Additional terms, permissive or non-permissive, may be stated in the form of a separately written license, or stated as exceptions; the above requirements apply either way. 8. Termination. You may not propagate or modify a covered work except as expressly provided under this License. Any attempt otherwise to propagate or modify it is void, and will automatically terminate your rights under this License (including any patent licenses granted under the third paragraph of section 11). However, if you cease all violation of this License, then your license from a particular copyright holder is reinstated (a) provisionally, unless and until the copyright holder explicitly and finally terminates your license, and (b) permanently, if the copyright holder fails to notify you of the violation by some reasonable means prior to 60 days after the cessation. Moreover, your license from a particular copyright holder is reinstated permanently if the copyright holder notifies you of the violation by some reasonable means, this is the first time you have received notice of violation of this License (for any work) from that copyright holder, and you cure the violation prior to 30 days after your receipt of the notice. Termination of your rights under this section does not terminate the licenses of parties who have received copies or rights from you under this License. If your rights have been terminated and not permanently reinstated, you do not qualify to receive new licenses for the same material under section 10. 9. Acceptance Not Required for Having Copies. You are not required to accept this License in order to receive or run a copy of the Program. Ancillary propagation of a covered work occurring solely as a consequence of using peer-to-peer transmission to receive a copy likewise does not require acceptance. However, nothing other than this License grants you permission to propagate or modify any covered work. These actions infringe copyright if you do not accept this License. Therefore, by modifying or propagating a covered work, you indicate your acceptance of this License to do so. 10. Automatic Licensing of Downstream Recipients. Each time you convey a covered work, the recipient automatically receives a license from the original licensors, to run, modify and propagate that work, subject to this License. You are not responsible for enforcing compliance by third parties with this License. An \"entity transaction\" is a transaction transferring control of an organization, or substantially all assets of one, or subdividing an organization, or merging organizations. If propagation of a covered work results from an entity transaction, each party to that transaction who receives a copy of the work also receives whatever licenses to the work the party's predecessor in interest had or could give under the previous paragraph, plus a right to possession of the Corresponding Source of the work from the predecessor in interest, if the predecessor has it or can get it with reasonable efforts. You may not impose any further restrictions on the exercise of the rights granted or affirmed under this License. For example, you may not impose a license fee, royalty, or other charge for exercise of rights granted under this License, and you may not initiate litigation (including a cross-claim or counterclaim in a lawsuit) alleging that any patent claim is infringed by making, using, selling, offering for sale, or importing the Program or any portion of it. 11. Patents. A \"contributor\" is a copyright holder who authorizes use under this License of the Program or a work on which the Program is based. The work thus licensed is called the contributor's \"contributor version\". A contributor's \"essential patent claims\" are all patent claims owned or controlled by the contributor, whether already acquired or hereafter acquired, that would be infringed by some manner, permitted by this License, of making, using, or selling its contributor version, but do not include claims that would be infringed only as a consequence of further modification of the contributor version. For purposes of this definition, \"control\" includes the right to grant patent sublicenses in a manner consistent with the requirements of this License. Each contributor grants you a non-exclusive, worldwide, royalty-free patent license under the contributor's essential patent claims, to make, use, sell, offer for sale, import and otherwise run, modify and propagate the contents of its contributor version. In the following three paragraphs, a \"patent license\" is any express agreement or commitment, however denominated, not to enforce a patent (such as an express permission to practice a patent or covenant not to sue for patent infringement). To \"grant\" such a patent license to a party means to make such an agreement or commitment not to enforce a patent against the party. If you convey a covered work, knowingly relying on a patent license, and the Corresponding Source of the work is not available for anyone to copy, free of charge and under the terms of this License, through a publicly available network server or other readily accessible means, then you must either (1) cause the Corresponding Source to be so available, or (2) arrange to deprive yourself of the benefit of the patent license for this particular work, or (3) arrange, in a manner consistent with the requirements of this License, to extend the patent license to downstream recipients. \"Knowingly relying\" means you have actual knowledge that, but for the patent license, your conveying the covered work in a country, or your recipient's use of the covered work in a country, would infringe one or more identifiable patents in that country that you have reason to believe are valid. If, pursuant to or in connection with a single transaction or arrangement, you convey, or propagate by procuring conveyance of, a covered work, and grant a patent license to some of the parties receiving the covered work authorizing them to use, propagate, modify or convey a specific copy of the covered work, then the patent license you grant is automatically extended to all recipients of the covered work and works based on it. A patent license is \"discriminatory\" if it does not include within the scope of its coverage, prohibits the exercise of, or is conditioned on the non-exercise of one or more of the rights that are specifically granted under this License. You may not convey a covered work if you are a party to an arrangement with a third party that is in the business of distributing software, under which you make payment to the third party based on the extent of your activity of conveying the work, and under which the third party grants, to any of the parties who would receive the covered work from you, a discriminatory patent license (a) in connection with copies of the covered work conveyed by you (or copies made from those copies), or (b) primarily for and in connection with specific products or compilations that contain the covered work, unless you entered into that arrangement, or that patent license was granted, prior to 28 March 2007. Nothing in this License shall be construed as excluding or limiting any implied license or other defenses to infringement that may otherwise be available to you under applicable patent law. 12. No Surrender of Others' Freedom. If conditions are imposed on you (whether by court order, agreement or otherwise) that contradict the conditions of this License, they do not excuse you from the conditions of this License. If you cannot convey a covered work so as to satisfy simultaneously your obligations under this License and any other pertinent obligations, then as a consequence you may not convey it at all. For example, if you agree to terms that obligate you to collect a royalty for further conveying from those to whom you convey the Program, the only way you could satisfy both those terms and this License would be to refrain entirely from conveying the Program. 13. Use with the GNU Affero General Public License. Notwithstanding any other provision of this License, you have permission to link or combine any covered work with a work licensed under version 3 of the GNU Affero General Public License into a single combined work, and to convey the resulting work. The terms of this License will continue to apply to the part which is the covered work, but the special requirements of the GNU Affero General Public License, section 13, concerning interaction through a network will apply to the combination as such. 14. Revised Versions of this License. The Free Software Foundation may publish revised and/or new versions of the GNU General Public License from time to time. Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns. Each version is given a distinguishing version number. If the Program specifies that a certain numbered version of the GNU General Public License \"or any later version\" applies to it, you have the option of following the terms and conditions either of that numbered version or of any later version published by the Free Software Foundation. If the Program does not specify a version number of the GNU General Public License, you may choose any version ever published by the Free Software Foundation. If the Program specifies that a proxy can decide which future versions of the GNU General Public License can be used, that proxy's public statement of acceptance of a version permanently authorizes you to choose that version for the Program. Later license versions may give you additional or different permissions. However, no additional obligations are imposed on any author or copyright holder as a result of your choosing to follow a later version. 15. Disclaimer of Warranty. THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION. 16. Limitation of Liability. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. 17. Interpretation of Sections 15 and 16. If the disclaimer of warranty and limitation of liability provided above cannot be given local legal effect according to their terms, reviewing courts shall apply local law that most closely approximates an absolute waiver of all civil liability in connection with the Program, unless a warranty or assumption of liability accompanies a copy of the Program in return for a fee. END OF TERMS AND CONDITIONS How to Apply These Terms to Your New Programs If you develop a new program, and you want it to be of the greatest possible use to the public, the best way to achieve this is to make it free software which everyone can redistribute and change under these terms. To do so, attach the following notices to the program. It is safest to attach them to the start of each source file to most effectively state the exclusion of warranty; and each file should have at least the \"copyright\" line and a pointer to where the full notice is found. <one line to give the program's name and a brief idea of what it does.> Copyright (C) <year> <name of author> This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program. If not, see <http://www.gnu.org/licenses/>. Also add information on how to contact you by electronic and paper mail. If the program does terminal interaction, make it output a short notice like this when it starts in an interactive mode: <program> Copyright (C) <year> <name of author> This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'. This is free software, and you are welcome to redistribute it under certain conditions; type `show c' for details. The hypothetical commands `show w' and `show c' should show the appropriate parts of the General Public License. Of course, your program's commands might be different; for a GUI interface, you would use an \"about box\". You should also get your employer (if you work as a programmer) or school, if any, to sign a \"copyright disclaimer\" for the program, if necessary. For more information on this, and how to apply and follow the GNU GPL, see <http://www.gnu.org/licenses/>. The GNU General Public License does not permit incorporating your program into proprietary programs. If your program is a subroutine library, you may consider it more useful to permit linking proprietary applications with the library. If this is what you want to do, use the GNU Lesser General Public License instead of this License. But first, please read <http://www.gnu.org/philosophy/why-not-lgpl.html>.","title":"License"},{"location":"problems/","text":"Problems and shortcomings dw-link is still in beta state. The most obvious errors have been fixed, but there are most probably others. If something does not go according to plan, please try to isolate the reason for the erroneous behavior, i.e., identify a sequence of operations to replicate the error. The most serious errors are fatal errors , which stop the debugger from working. With the command monitor info you can get information on the last fatal error (check the error table at the end of the troubleshooting section ). One perfect way to document a debugger error is to switch on logging and command tracing in the debugger: set trace-commands on set remote debug 1 set logging on ... set logging off This can either be done during the interactive debug session or in the .gdbinit file in the home directory. The latter is preferable if the problem happens before the session is started using target remote ... . Apart from bugs, there are, of course, shortcomings that one cannot avoid. I will present some of them in the next subsections. Flash memory wear Setting and removing breakpoints is one of the main functionality of a debugger. Setting a breakpoint is mainly accomplished by changing an instruction in flash memory to the BREAK instruction. This, however, implies that one has to reprogram flash memory . Since flash memory wears out, one should try to minimize the number of flash memory reprogramming operations. GDB does not pass breakpoint set and breakpoint delete commands from the user to the hardware debugger, but instead, it sends a list of breakpoint set commands before execution starts. After execution stops, it sends breakpoint delete commands for all breakpoints. In particular, when thinking about conditional breakpoints, it becomes clear that GDB may send a large number of breakpoint set and breakpoint delete commands for one breakpoint during one debug session. Although it is guaranteed that flash memory can be reprogrammed at least 10,000 times according to the data sheets, this number can easily be reached even in a few debug sessions, provided there are loops that are often executed and where a conditional breakpoint has been inserted. Fortunately, the situation is not as bad as it looks since there are many ways of getting around the need of reprogramming flash memory. First, dw-link leaves the breakpoints in memory even when GDB requests to remove them. The breakpoints in flash memory are updated only when GDB requests to continue execution. Assuming that the user does not change breakpoints too often, this will significantly reduce flash reprogramming. Second, if there are many breakpoints on the same flash page, the page is reprogrammed only once instead of individually for each breakpoint. Third, when one restarts from a location where a breakpoint has been set, GDB temporarily removes this breakpoint, single-steps to the next instruction, reinserts the breakpoint, and only then continues execution. This would lead to two reprogramming operations. However, dw-link does not update flash memory before single-stepping. Instead, if the instruction is a single-word instruction, it loads the original instruction into the MCU's instruction register and executes it there. For two-word instructions (i.e., LDS, STS, JUMP, and CALL), things are a bit more complicated. The Microchip documents state that one should refrain from inserting breakpoints at double-word instructions, implying that this would create problems. Indeed, RikusW noted in his reverse engineering notes about debugWIRE : Seems that its not possible to execute a 32 bit instruction this way. The Dragon reflash the page to remove the SW BP, SS and then reflash again with the SW BP!!! I noticed that this is still the case, i.e., MPLAB-X in connection with ATMEL-ICE still reprograms the page twice for hitting a breakpoint at a two-word instruction. The more sensible solution is to simulate the execution of these instructions, which is at least as fast and saves two reprogramming operations. And this is what dw-link does. Fourth, each MCU contains one hardware breakpoint register , which stops the MCU when the value in the register equals the program counter. Dw-link uses this for the breakpoint introduced most recently. With this heuristic, temporary breakpoints (as the ones GDB generates for single-stepping) will always get priority and more permanent breakpoints set by the user will end up in flash. Fifth, when reprogramming of a flash page is requested, dw-link first checks whether the identical contents should be loaded, in which case it does nothing. Further, it checks whether it is possible to achieve the result by just turning some 1's into 0's. Only if these two things are not possible, the flash page is erased and reprogrammed. This helps in particular when reloading a file with the GDB load command after only a few things in the program have been changed. With all of that in mind, you do not have to worry too much about flash memory wear when debugging. As a general rule, you should not make massive changes to the breakpoints each time the MCU stops executing. Finally, Microchip recommends that chips that have been used for debugging using debugWIRE should not be shipped to customers. Well, I never ship chips to customers anyway. For the really paranoid, there is the option that permits only one breakpoint, i.e., the hardware breakpoint: monitor breakpoint hardware . In this case, one either can set one breakpoint or one can single-step, but not both. So, if you want to continue after a break by single-stepping, you first have to delete the breakpoint. By the way, with monitor breakpoint all , one switches back to normal mode, in which 20 (including one temporary) breakpoints are allowed. In addition, the debugger command monitor info shows the number of flash page reprogramming commands executed since the debugger was started. This also includes the flash reprogramming commands needed when loading code. Slow responses when loading or single-stepping Sometimes, in particular, when using a clock speed below 1 MHz, responses from the MCU can be quite sluggish. This shows, e.g., when loading code or single-stepping. The reason is that a lot of communication over the RESET line is going on in these cases and the communication speed is set to the MCU clock frequency divided by 8, which is roughly 16000 bps in case of a 128 kHz MCU clock. If the CKDIV8 fuse is programmed, i.e., the MCU clock uses a prescaler of 8, then we are down to 16 kHz MCU clock and 2000 bps. The Atmel AVR JTAGICE mkII manual states under known issues : Setting the CLKDIV8 fuse can cause connection problems when using debugWIRE. For best results, leave this fuse un-programmed during debugging. \"Leaving the fuse un-programmed\" means that you probably have to change the fuse to be un-programmed using a fuse-programmer, because the fuse is programmed by default. With 125 kbps for the debugWIRE line, loading is done with 600 bytes/second. It is 4 KiB/second when the identical file is loaded again (in which case only a comparison with the already loaded file is performed). Program execution is very slow when conditional breakpoints are present If you use conditional breakpoints , the program is slowed down significantly. The reason is that at such a breakpoint, the program has to be stopped, all registers have to be saved, the current values of the variables have to be inspected, and then the program needs to be started again, whereby registers have to be restored first. For all of these operations, debugWIRE communication takes place. This takes roughly 100 ms per stop, even for simple conditions and an MCU running at 8MHz. So, if you have a loop that iterates 1000 times before the condition is met, it may easily take 2 minutes (instead of a fraction of a second) before execution stops. Single-stepping and interrupt handling clash In many debuggers, it is impossible to do single-stepping when timer interrupts are active since, after a step, the program may end up in the interrupt routine. This is not the case with avr-gdb and dw-link. Instead, time is frozen and interrupts cannot be raised while the debugger single-steps. Only when the continue command is used, interrupts are serviced and the timers are advanced. One can change this behavior by using the command monitor singlestep interruptible . In this case, it can happen that control is transferred to the interrupt vector table while single-stepping. Limited number of breakpoints The hardware debugger supports only a limited number of breakpoints. Currently, 20 breakpoints (including one temporary breakpoint for single-stepping) are supported by default. You can reduce this to 1 by issuing the command monitor breakpoint hardware ( see above ). If you set more breakpoints than the maximum number, it will not be possible to start execution. Instead one will get the warning Cannot insert breakpoint ... Command aborted . You have to delete or disable some breakpoints before program execution can continue. However, you should not use that many breakpoints in any case. One to five breakpoints are usually enough. Power saving is not operational When you activate sleep mode , the power consumed by the MCU is supposed to go down significantly. If debugWIRE is active, then some timer/counters will never be stopped and for this reason the power reduction is not as high as in normal state. MCU operations interfering with debugWIRE There are a few situations where MCU operations interfere with the debugWIRE system. The above-mentioned list of known issues contains the following: The PRSPI bit in the power-saving register should not be set Do not single step over a SLEEP instruction Breakpoints should not be set at the last address of flash memory Do not insert breakpoints immediately after an LPM instruction and do not single-step LPM code. Setting the PRSPI bit can disable the clock for the debugWIRE line and should be avoided for this reason. If a SLEEP instruction is requested to be single-stepped, in dw-link, a NOP will be executed instead. This is apparently what happens in Microchip's debuggers as well. Setting a breakpoint to the last address of flash memory hardly ever happens when source-level debugging. Single-stepping over LPM instructions can corrupt the flash memory display in Atmel Studio. However, we can safely ignore this. The list of known issues mentions also the following five potential problems: Be aware that the On-chip Debug system is disabled when any lock bits are set BOD and WDT resets lead to loss of connection The OSCCAL and CLKPR registers should not be changed during a debug session The voltage should not be changed during a debug session The CKDIV8 fuse should not be in the programmed state when running off a 128 kHz clock source The first issue is mitigated by dw-link erasing the chip when lock bits are set. This is not an industrial-strength solution, but it makes life easier because all UNO boards have their lock bits set initially. So, instead of explaining that the bits have to be cleared, it is just done automatically. Concerning resets, I did not experience fundamental problems. The only issue was that the target would not stop at the hardware breakpoint after a reset, since the reset will clear this hardware breakpoint. So, if you want to be sure to stop after a reset, use the command monitor breakpoint software , which forces all breakpoints to be software breakpoints. If you use the watchdog timer to issue a software reset, make sure that right after restarting the MCU, the watchdog timer will be disabled, as mentioned in the AVR-LibC FAQ . Otherwise, you run into a WDT-restart loop. Changing the clock frequency is also not a problem since, at each stop, the debugger re-synchronizes with the target. Further, changing the supply voltage can be done if you have level-shifting hardware in place. It is still not something that is recommended. Finally, debugging at very low clock frequencies (32 kHz/8 = 4 kHz) is not impossible, but communication is extremely slow. I have implemented that mainly because of curiosity. BREAK instructions in your program It is possible to put the BREAK instruction, which is used to implement breakpoints, in ones program by using the inline assembly statement asm(\"break\") . This makes no sense since, without the debugger, the MCU will treat this instruction as a NOP. Such a BREAK instruction may also be in the program because a previous debugging session was not terminated in a clean way. When running under the debugger, the program will be stopped in the same way as if there is a software breakpoint set by the user. However, one cannot continue execution from this point with the step , next , or continue command. You will always get a SIGILL signal. So, one needs to reload the program code, set the PC to a different value, or restart the debugging session. Some MCUs have stuck-at-one bits in the program counter Some debugWIRE MCUs appear to have program counters in which some unused bits are stuck at one. ATmega48s and ATmega88s (without the A-suffix), which I have sitting on my bench, have their PC bits 11 and 12 or only PC bit 12 always stuck at one. In other words, the PC has at least the value 0x1800 or 0x1000, respectively (note that the AVR program counter addresses words, not bytes!). The hardware debugger can deal with it, but GDB gets confused when trying to perform a stack backtrace. It also gets confused when trying to step over a function call or tries to finalize a function call. For these reasons, debugging these MCUs does not make much sense and dw-link rejects these MCUs with an error message when one tries to connect to one of those (see also this blog entry ). The only reasonable way to deal with this problem is to use a different MCU, one with an A, PA, or PB suffix. The start of the debugger takes two seconds The reason is that when the host establishes a connection to the debugger, the debugger is reset and the bootloader waits two seconds. You can avoid that by disabling the auto-reset feature putting a capacitor of 10 \u00b5F or more between RESET and GND. The dw-link probe shield also does that for you. Code optimization reorganizes code and makes it impossible to stop at a particular source line or to inspect or change values of local variables The standard setting of the Arduino IDE and CLI is to optimize for space, which is accomplished using the compiler option -Os . In this case, it may be difficult to stop at some source lines, and single-stepping may give strange results. When you choose Optimize for Debugging in the Sketch menu, then the compiler optimizes the code in a debugger-friendly way (using the compiler option -Og ). I have encountered situations when it was impossible to get the right information about C++ objects . This can be avoided by disabling link-time optimization (LTO). Finally, if there are still discrepancies between what you expect and what the debugger delivers, you can try to set -O0 -fno-lto , which you only can do when compiling the sketch with arduino-cli. In PlatformIO, you can set the options for generating the debug binary in the platform.ini file.","title":"Problems"},{"location":"problems/#problems-and-shortcomings","text":"dw-link is still in beta state. The most obvious errors have been fixed, but there are most probably others. If something does not go according to plan, please try to isolate the reason for the erroneous behavior, i.e., identify a sequence of operations to replicate the error. The most serious errors are fatal errors , which stop the debugger from working. With the command monitor info you can get information on the last fatal error (check the error table at the end of the troubleshooting section ). One perfect way to document a debugger error is to switch on logging and command tracing in the debugger: set trace-commands on set remote debug 1 set logging on ... set logging off This can either be done during the interactive debug session or in the .gdbinit file in the home directory. The latter is preferable if the problem happens before the session is started using target remote ... . Apart from bugs, there are, of course, shortcomings that one cannot avoid. I will present some of them in the next subsections.","title":"Problems and shortcomings"},{"location":"problems/#flash-memory-wear","text":"Setting and removing breakpoints is one of the main functionality of a debugger. Setting a breakpoint is mainly accomplished by changing an instruction in flash memory to the BREAK instruction. This, however, implies that one has to reprogram flash memory . Since flash memory wears out, one should try to minimize the number of flash memory reprogramming operations. GDB does not pass breakpoint set and breakpoint delete commands from the user to the hardware debugger, but instead, it sends a list of breakpoint set commands before execution starts. After execution stops, it sends breakpoint delete commands for all breakpoints. In particular, when thinking about conditional breakpoints, it becomes clear that GDB may send a large number of breakpoint set and breakpoint delete commands for one breakpoint during one debug session. Although it is guaranteed that flash memory can be reprogrammed at least 10,000 times according to the data sheets, this number can easily be reached even in a few debug sessions, provided there are loops that are often executed and where a conditional breakpoint has been inserted. Fortunately, the situation is not as bad as it looks since there are many ways of getting around the need of reprogramming flash memory. First, dw-link leaves the breakpoints in memory even when GDB requests to remove them. The breakpoints in flash memory are updated only when GDB requests to continue execution. Assuming that the user does not change breakpoints too often, this will significantly reduce flash reprogramming. Second, if there are many breakpoints on the same flash page, the page is reprogrammed only once instead of individually for each breakpoint. Third, when one restarts from a location where a breakpoint has been set, GDB temporarily removes this breakpoint, single-steps to the next instruction, reinserts the breakpoint, and only then continues execution. This would lead to two reprogramming operations. However, dw-link does not update flash memory before single-stepping. Instead, if the instruction is a single-word instruction, it loads the original instruction into the MCU's instruction register and executes it there. For two-word instructions (i.e., LDS, STS, JUMP, and CALL), things are a bit more complicated. The Microchip documents state that one should refrain from inserting breakpoints at double-word instructions, implying that this would create problems. Indeed, RikusW noted in his reverse engineering notes about debugWIRE : Seems that its not possible to execute a 32 bit instruction this way. The Dragon reflash the page to remove the SW BP, SS and then reflash again with the SW BP!!! I noticed that this is still the case, i.e., MPLAB-X in connection with ATMEL-ICE still reprograms the page twice for hitting a breakpoint at a two-word instruction. The more sensible solution is to simulate the execution of these instructions, which is at least as fast and saves two reprogramming operations. And this is what dw-link does. Fourth, each MCU contains one hardware breakpoint register , which stops the MCU when the value in the register equals the program counter. Dw-link uses this for the breakpoint introduced most recently. With this heuristic, temporary breakpoints (as the ones GDB generates for single-stepping) will always get priority and more permanent breakpoints set by the user will end up in flash. Fifth, when reprogramming of a flash page is requested, dw-link first checks whether the identical contents should be loaded, in which case it does nothing. Further, it checks whether it is possible to achieve the result by just turning some 1's into 0's. Only if these two things are not possible, the flash page is erased and reprogrammed. This helps in particular when reloading a file with the GDB load command after only a few things in the program have been changed. With all of that in mind, you do not have to worry too much about flash memory wear when debugging. As a general rule, you should not make massive changes to the breakpoints each time the MCU stops executing. Finally, Microchip recommends that chips that have been used for debugging using debugWIRE should not be shipped to customers. Well, I never ship chips to customers anyway. For the really paranoid, there is the option that permits only one breakpoint, i.e., the hardware breakpoint: monitor breakpoint hardware . In this case, one either can set one breakpoint or one can single-step, but not both. So, if you want to continue after a break by single-stepping, you first have to delete the breakpoint. By the way, with monitor breakpoint all , one switches back to normal mode, in which 20 (including one temporary) breakpoints are allowed. In addition, the debugger command monitor info shows the number of flash page reprogramming commands executed since the debugger was started. This also includes the flash reprogramming commands needed when loading code.","title":"Flash memory wear"},{"location":"problems/#slow-responses-when-loading-or-single-stepping","text":"Sometimes, in particular, when using a clock speed below 1 MHz, responses from the MCU can be quite sluggish. This shows, e.g., when loading code or single-stepping. The reason is that a lot of communication over the RESET line is going on in these cases and the communication speed is set to the MCU clock frequency divided by 8, which is roughly 16000 bps in case of a 128 kHz MCU clock. If the CKDIV8 fuse is programmed, i.e., the MCU clock uses a prescaler of 8, then we are down to 16 kHz MCU clock and 2000 bps. The Atmel AVR JTAGICE mkII manual states under known issues : Setting the CLKDIV8 fuse can cause connection problems when using debugWIRE. For best results, leave this fuse un-programmed during debugging. \"Leaving the fuse un-programmed\" means that you probably have to change the fuse to be un-programmed using a fuse-programmer, because the fuse is programmed by default. With 125 kbps for the debugWIRE line, loading is done with 600 bytes/second. It is 4 KiB/second when the identical file is loaded again (in which case only a comparison with the already loaded file is performed).","title":"Slow responses when loading or single-stepping"},{"location":"problems/#program-execution-is-very-slow-when-conditional-breakpoints-are-present","text":"If you use conditional breakpoints , the program is slowed down significantly. The reason is that at such a breakpoint, the program has to be stopped, all registers have to be saved, the current values of the variables have to be inspected, and then the program needs to be started again, whereby registers have to be restored first. For all of these operations, debugWIRE communication takes place. This takes roughly 100 ms per stop, even for simple conditions and an MCU running at 8MHz. So, if you have a loop that iterates 1000 times before the condition is met, it may easily take 2 minutes (instead of a fraction of a second) before execution stops.","title":"Program execution is very slow when conditional breakpoints are present"},{"location":"problems/#single-stepping-and-interrupt-handling-clash","text":"In many debuggers, it is impossible to do single-stepping when timer interrupts are active since, after a step, the program may end up in the interrupt routine. This is not the case with avr-gdb and dw-link. Instead, time is frozen and interrupts cannot be raised while the debugger single-steps. Only when the continue command is used, interrupts are serviced and the timers are advanced. One can change this behavior by using the command monitor singlestep interruptible . In this case, it can happen that control is transferred to the interrupt vector table while single-stepping.","title":"Single-stepping and interrupt handling clash"},{"location":"problems/#limited-number-of-breakpoints","text":"The hardware debugger supports only a limited number of breakpoints. Currently, 20 breakpoints (including one temporary breakpoint for single-stepping) are supported by default. You can reduce this to 1 by issuing the command monitor breakpoint hardware ( see above ). If you set more breakpoints than the maximum number, it will not be possible to start execution. Instead one will get the warning Cannot insert breakpoint ... Command aborted . You have to delete or disable some breakpoints before program execution can continue. However, you should not use that many breakpoints in any case. One to five breakpoints are usually enough.","title":"Limited number of breakpoints"},{"location":"problems/#power-saving-is-not-operational","text":"When you activate sleep mode , the power consumed by the MCU is supposed to go down significantly. If debugWIRE is active, then some timer/counters will never be stopped and for this reason the power reduction is not as high as in normal state.","title":"Power saving is not operational"},{"location":"problems/#mcu-operations-interfering-with-debugwire","text":"There are a few situations where MCU operations interfere with the debugWIRE system. The above-mentioned list of known issues contains the following: The PRSPI bit in the power-saving register should not be set Do not single step over a SLEEP instruction Breakpoints should not be set at the last address of flash memory Do not insert breakpoints immediately after an LPM instruction and do not single-step LPM code. Setting the PRSPI bit can disable the clock for the debugWIRE line and should be avoided for this reason. If a SLEEP instruction is requested to be single-stepped, in dw-link, a NOP will be executed instead. This is apparently what happens in Microchip's debuggers as well. Setting a breakpoint to the last address of flash memory hardly ever happens when source-level debugging. Single-stepping over LPM instructions can corrupt the flash memory display in Atmel Studio. However, we can safely ignore this. The list of known issues mentions also the following five potential problems: Be aware that the On-chip Debug system is disabled when any lock bits are set BOD and WDT resets lead to loss of connection The OSCCAL and CLKPR registers should not be changed during a debug session The voltage should not be changed during a debug session The CKDIV8 fuse should not be in the programmed state when running off a 128 kHz clock source The first issue is mitigated by dw-link erasing the chip when lock bits are set. This is not an industrial-strength solution, but it makes life easier because all UNO boards have their lock bits set initially. So, instead of explaining that the bits have to be cleared, it is just done automatically. Concerning resets, I did not experience fundamental problems. The only issue was that the target would not stop at the hardware breakpoint after a reset, since the reset will clear this hardware breakpoint. So, if you want to be sure to stop after a reset, use the command monitor breakpoint software , which forces all breakpoints to be software breakpoints. If you use the watchdog timer to issue a software reset, make sure that right after restarting the MCU, the watchdog timer will be disabled, as mentioned in the AVR-LibC FAQ . Otherwise, you run into a WDT-restart loop. Changing the clock frequency is also not a problem since, at each stop, the debugger re-synchronizes with the target. Further, changing the supply voltage can be done if you have level-shifting hardware in place. It is still not something that is recommended. Finally, debugging at very low clock frequencies (32 kHz/8 = 4 kHz) is not impossible, but communication is extremely slow. I have implemented that mainly because of curiosity.","title":"MCU operations interfering with debugWIRE"},{"location":"problems/#break-instructions-in-your-program","text":"It is possible to put the BREAK instruction, which is used to implement breakpoints, in ones program by using the inline assembly statement asm(\"break\") . This makes no sense since, without the debugger, the MCU will treat this instruction as a NOP. Such a BREAK instruction may also be in the program because a previous debugging session was not terminated in a clean way. When running under the debugger, the program will be stopped in the same way as if there is a software breakpoint set by the user. However, one cannot continue execution from this point with the step , next , or continue command. You will always get a SIGILL signal. So, one needs to reload the program code, set the PC to a different value, or restart the debugging session.","title":"BREAK instructions in your program"},{"location":"problems/#some-mcus-have-stuck-at-one-bits-in-the-program-counter","text":"Some debugWIRE MCUs appear to have program counters in which some unused bits are stuck at one. ATmega48s and ATmega88s (without the A-suffix), which I have sitting on my bench, have their PC bits 11 and 12 or only PC bit 12 always stuck at one. In other words, the PC has at least the value 0x1800 or 0x1000, respectively (note that the AVR program counter addresses words, not bytes!). The hardware debugger can deal with it, but GDB gets confused when trying to perform a stack backtrace. It also gets confused when trying to step over a function call or tries to finalize a function call. For these reasons, debugging these MCUs does not make much sense and dw-link rejects these MCUs with an error message when one tries to connect to one of those (see also this blog entry ). The only reasonable way to deal with this problem is to use a different MCU, one with an A, PA, or PB suffix.","title":"Some MCUs have stuck-at-one bits in the program counter"},{"location":"problems/#the-start-of-the-debugger-takes-two-seconds","text":"The reason is that when the host establishes a connection to the debugger, the debugger is reset and the bootloader waits two seconds. You can avoid that by disabling the auto-reset feature putting a capacitor of 10 \u00b5F or more between RESET and GND. The dw-link probe shield also does that for you.","title":"The start of the debugger takes two seconds"},{"location":"problems/#code-optimization-reorganizes-code-and-makes-it-impossible-to-stop-at-a-particular-source-line-or-to-inspect-or-change-values-of-local-variables","text":"The standard setting of the Arduino IDE and CLI is to optimize for space, which is accomplished using the compiler option -Os . In this case, it may be difficult to stop at some source lines, and single-stepping may give strange results. When you choose Optimize for Debugging in the Sketch menu, then the compiler optimizes the code in a debugger-friendly way (using the compiler option -Og ). I have encountered situations when it was impossible to get the right information about C++ objects . This can be avoided by disabling link-time optimization (LTO). Finally, if there are still discrepancies between what you expect and what the debugger delivers, you can try to set -O0 -fno-lto , which you only can do when compiling the sketch with arduino-cli. In PlatformIO, you can set the options for generating the debug binary in the platform.ini file.","title":"Code optimization reorganizes code and makes it impossible to stop at a particular source line or to inspect or change values of local variables"},{"location":"quickstart-AVR-GDB/","text":"Quick-start guide: AVR-GDB debugging Turn your Arduino Uno into a hardware debugger that can be used for embedded debugging of classic AVR chips in 7 easy steps. This quickstart guide explains how to use the GNU Debugger GDB . If you want to use the Arduino IDE 2 , consult the alternative quickstart guide for Arduino IDE 2 debugging . What you need Computer running Windows, macOS, or Linux (the host ) Arduino Uno (will become the hardware debugger ) USB cable ATtiny85 (or any other classic ATtiny or ATmegaX8) as the target In order to connect the hardware debugger to the target, you need: a breadboard together with 11 Jumper wires (male-to-male) 2 LEDs 3 Resistors (10 k\u03a9, 220\u03a9, 220\u03a9) 2 Capacitors (100 nF, 10 \u00b5F) Step 1: Install Arduino IDE 2 or arduino-cli You probably already have installed the Arduino IDE 2. If not, download and install it from https://arduino.cc. Alternatively, you can install arduino-cli. Check: Start IDE and check the About Arduino entry under the Arduino or Help menu for the version number. It should be >= 2.3.0. Step 2: Install new board manager files Open the Preferences dialog of the Arduino IDE and paste the following Board Manager URLs into the list: https://downloads.pyavrocd.io/package_debugging_index.json https://mcudude.github.io/MiniCore/package_MCUdude_MiniCore_index.json https://mcudude.github.io/MicroCore/package_MCUdude_MicroCore_index.json Close the Preference dialog with OK . Now, you can install the cores, ATTinyCore (Debug enabled) , MiniCore , and MicroCore . Select Tools -> Board -> Board Managers ... . This will open the Boards Manager dialog. In the search field, type ATTinyCore(Debug enabled) and install the most recent version. Afterward, do the same with MiniCore and MicroCore . Check: Select Tools -> Board -> ATtinyCore (Debug enabled) -> Attiny25/45/85 (no bootloader) . The debug button in the upper row (3rd from the left) is no longer greyed out. Step 3: Install dw-link firmware First, connect the UNO to your computer using the USB cable. Make sure that you have the permission to access the serial interface (under Linux). The simplest way to install the firmware is to download an uploader from the Release assets of the GitHub repo . The uploader should fit your architecture, e.g., dw-uploader-windows-intel64 for Windows. Under Linux and macOS , open a terminal window, go to the download folder, and set the executable permission using chmod +x . Afterward, execute the program. Under Windows , it is enough to start the program after downloading by double-clicking on it. Alternatively, you can download or clone the dw-link repository and then compile and upload the dw-link Arduino sketch using the Arduino IDE 2. Check: Open the Serial Monitor (under the Tools menu), choose 115200 baud , type - (minus sign) into the upper line, and send it. The hardware debugger should respond with $#00 . Step 4: Install avr-gdb on the host computer The installation of the board definition files will lead to the download of a recent version of the GDB debug client in the tools section of the respective package. You should be able to copy it to a place in your PATH , e.g., /usr/local/bin . On a Mac: ~/Library/Arduino15/packages/MiniCore/tools/avrocd-tools/XXX/avr-gdb Under Linux : ~/.arduino15/packages/MiniCore/tools/avrocd-tools/XXX/avr-gdb Under Windows: C:\\Users\\\\{username}\\AppData\\Local\\Arduino15\\packages\\MiniCore\\tools\\avrocd-tools\\XXX\\avr-gdb.exe If the file is not there, you can install it from other sources, as described below. On a Mac: If you have not done so, you must install the package manager Homebrew first. Go to https://brew.sh/ and follow the instructions. Installing Homebrew can take some considerable time. After that, you can install avr-gdb, the host debug client, by typing the following line into a shell: brew tap osx-cross/avr && brew install avr-gdb Under Linux: You can install avr-gdb using the appropriate packet manager. For Debian/Ubuntu, that looks as follows (note that the package is indeed named gdb-avr): sudo apt-get install gdb-avr Under Windows: The easiest way to get hold of avr-gdb is probably to download the avr-gcc toolchain from Zak's blog: https://blog.zakkemble.net/avr-gcc-builds/. Then unzip and copy /bin/avr-gdb to some place, e.g., C:\\Progam Files\\bin\\ . Afterward, you should put this path into the Windows PATH variable. This means you type System into the search field on the control panel, click on Advanced Settings , click on Environment Variables , and then add C:\\Progam Files\\bin to the PATH environment variable. Check: Open a terminal window and type avr-gdb . This should start the debugger, which you can quit by typing quit . Step 5: Hardware setup This description is for debugging an ATtiny85. However, almost any other classic ATtiny or ATmegaX8 would do. Just be aware that when trying to debug an Arduino Uno board, you need to alter the board physically (cut a solder bridge). How to set up an Uno as a target board is described in the dw-link manual . You need to set up the hardware on a breadboard and use six wires to connect the ATtiny to your Uno, turned into a hardware debugger. Note that the notch or dot on the ATtiny is oriented towards the left. Note that the notch or dot on the ATtiny is oriented towards the left. Here is a table of all the connections so that you can check that you have made all the connections. ATtiny pin# Arduino Uno pin component 1 (Reset) D8 10k resistor to Vcc 2 (D3) 3 (D4) 220 \u03a9 resistor to target (red) LED (+) 4 (GND) GND red and yellow LED (-), decoupling cap 100 nF, RESET blocking cap of 10\u00b5F (-) 5 (D0, MOSI) D11 6 (D1, MISO) D12 7 (D2, SCK) D13 8 (Vcc) 5V 10k resistor, decoupling cap 100 nF RESET RESET blocking cap of 10 \u00b5F (+) D7 220 \u03a9 to system (yellow) LED (+) The yellow LED is the system LED , and the red one is the ATtiny-LED . The system LED gives you information about the internal state of the debugger: debugWIRE mode disabled (LED is off), waiting for power-cycling the target (LED flashes every second for 0.1 sec),3. debugWIRE mode enabled (LED is on), ISP programming (LED is blinking slowly), error state, i.e., not possible to connect to target or internal error (LED blinks furiously every 0.1 sec). Check: Go through the table above and check every connection. Wrong wiring can often cause hours of useless software debugging! Step 6: Compiling the Arduino sketch for the target Either you use the arduino-cli to compile your sketch (and then I assume you know what you are doing), or you use the IDE: Load the sketch, you want to debug (e.g., dw-link-x.y.z/examples/varblink/varblink.ino ) into the IDE and select ATtiny25/45/85 (no bootloader) as the board. As Clock Source choose 1 MHz (internal) (assuming that the ATtiny is as it comes from the factory and no fuse has been changed). In the Sketch menu, you should now activate `Optimize for Debugging. When you now select Sketch -> Export compiled Binary , then the sketch will be compiled and an ELF file (a binary that contains debugging information) is placed into the folder build/<board-type>/ inside the sketch folder. You can also use arduino-cli to compile the sketch. Make sure to set the compiler option -Og , which makes sure that the compiler optimized for debugging (instead of for space). Check: Open terminal window and change into the sketch folder. The ELF file <sketchname>.ino.elf should either be in the the sketch folder or in a subdirectory of the build folder. Step 7: Debugging Now, we are ready to debug the sketch on the target chip. Check that the host , the computer you are sitting at, is connected to the hardware debugger , the Uno, with a USB cable. The hardware debugger should in turn be connected to the target chip, the ATtiny85, by 6 flying wires as we have prepared it in step 5. Open a terminal window and change into the folder where the ELF file resides. Then type avr-gdb -b 115200 <sketchname>.ino.elf where \\<sketchname> is the name of the Arduino sketch. This should fire up the avr-gdb debugger, which will prompt you with (gdb) . When you now type (gdb) target remote <serial-port> where \\<serial-port> is the serial port of the Uno, then, after a few seconds, one should get a message similar to the following one Remote debugging using <serial-port> 0x00000000 in __vectors () You are connected to the hardware debugger. Now you need to enable the debugWIRE mode: (gdb) monitor debugWIRE enable This will bring up the message *** Please power-cycle target *** asking you to switch power to the target off and the on again in order to acxtivate debugWIRE mode. If in repsonse to it, the following message appears Connected to ATmega328P debugWIRE is enabled, bps: 125244 and the system LED lights up, then you are in business! What else could happen? If the LED stays dark and you receive the message /dev/XXXXXXXX: Resource busy , then some other program is currently accessing the serial port. Perhaps there is still a monitor window open? Close that and try again. If the LED stays dark and you got the message Ignoring packet error, continuing... when trying to connect, then the hardware debugger could not be reached over the serial connection. Perhaps, wrong baud rate? If the LED is instead blinking quickly, then the hardware debugger could not connect to the target. Type monitor info , which should give you the reason. Probably: Wrong wiring. So check the wiring or maybe try a different MCU. Assuming that everything went according to plan, the only thing missing now is that the sketch is loaded into flash memory. But the next command will exactly do this: load After a while, the debugger will then tell you Loading section .text, size 0x714 lma 0x0 Loading section .data, size 0x4 lma 0x714 Start address 0x00000000, load size 1816 Transfer rate: 618 bytes/sec, 113 bytes/write. or something similar. Now, you really can get into it! Here is a short list of commands that are useful: l - list program text around current point and advances point l fn - list function fn b fn - puts a breakpoint at the beginning of function fn b num - puts a breakpoint at line num in current file i b - list breakpoints d num - deletes breakpoint number num c - continues running the program until the next breakpoint or stop by CTRL-C s - runs the next line of the program s num - run the next num lines of the program n - like s, but it does not step into functions monitor reset - resets MCUs and sets program counter to 0 bt - print the call stack p var - prints the current value of the variable var set variable var =*expr - sets var to new value expr* q - quits gdb CTRL-C while the programming is running stops the execution asynchronously There are tons of GDB commands, too many to show here! On the documentation page of GDB , you find an extensive manual and a useful PDF reference sheet . A list of monitor commands , which are specific to the dw-link debugger, can be found in the dw-link manual. After debugging When you are done with debugging, you probably want to disable the debugWIRE mode again, because in debugWIRE mode, you cannot use the RESET line or ISP programming. This can be accomplished by using the command monitor debugwire disable before you leave the debugger. After debugging, you can still can use dw-link as a programmer (of type Arduino as ISP ). It is not the fastest one, but if you do not have anything better, it will do its job. If you want a more durable hardware debugging solution, there are some suggestions in the dw-link manual. These days, however, the Microchip debugger MPLAP SNAP might be a better deal. You can use it as a drop-in replacement for dw-link; it costs less than US-$15, and it is able to do much more! What can go wrong? First, the dw-link firmware upload may fail. If so, try to use the conventional way by downloading the latest release version and then compiling and uploading the dw-link sketch. Second, if something does not work as advertised, it is often a simple wiring problem. Other possible sources of errors are installation errors, i.e., that a program is not installed at the right place, does not have the proper permissions, the PATH variable is incorrect, or one has installed the wrong board manager files. When some strange error messages show up, it may also indicate that some components have not been installed. Google for the error message! Often, there are hints on how to mitigate the problem. Finally, there is also a troubleshooting section in the dw-link manual, which may be helpful. The most annoying problem can be that an MCU might not be responsive anymore after a debugging session. The reason is that the RESET line, which is used as a communication line during debugging, has not been re-enabled. While a regular exit of the debugger restores the RESET line, the debugger may be terminated without restoring it. An easy cure is to enter the debugger again and leave it regularly (after connecting to the target chip) with the command quit . If this does not help, you may have to use a High-Voltage programmer, such as RescueAVR . If you think you have found a bug, please post it on issues .","title":"AVR-GDB"},{"location":"quickstart-AVR-GDB/#quick-start-guide-avr-gdb-debugging","text":"Turn your Arduino Uno into a hardware debugger that can be used for embedded debugging of classic AVR chips in 7 easy steps. This quickstart guide explains how to use the GNU Debugger GDB . If you want to use the Arduino IDE 2 , consult the alternative quickstart guide for Arduino IDE 2 debugging .","title":"Quick-start guide: AVR-GDB debugging"},{"location":"quickstart-AVR-GDB/#what-you-need","text":"Computer running Windows, macOS, or Linux (the host ) Arduino Uno (will become the hardware debugger ) USB cable ATtiny85 (or any other classic ATtiny or ATmegaX8) as the target In order to connect the hardware debugger to the target, you need: a breadboard together with 11 Jumper wires (male-to-male) 2 LEDs 3 Resistors (10 k\u03a9, 220\u03a9, 220\u03a9) 2 Capacitors (100 nF, 10 \u00b5F)","title":"What you need"},{"location":"quickstart-AVR-GDB/#step-1-install-arduino-ide-2-or-arduino-cli","text":"You probably already have installed the Arduino IDE 2. If not, download and install it from https://arduino.cc. Alternatively, you can install arduino-cli. Check: Start IDE and check the About Arduino entry under the Arduino or Help menu for the version number. It should be >= 2.3.0.","title":"Step 1: Install Arduino IDE 2 or arduino-cli"},{"location":"quickstart-AVR-GDB/#step-2-install-new-board-manager-files","text":"Open the Preferences dialog of the Arduino IDE and paste the following Board Manager URLs into the list: https://downloads.pyavrocd.io/package_debugging_index.json https://mcudude.github.io/MiniCore/package_MCUdude_MiniCore_index.json https://mcudude.github.io/MicroCore/package_MCUdude_MicroCore_index.json Close the Preference dialog with OK . Now, you can install the cores, ATTinyCore (Debug enabled) , MiniCore , and MicroCore . Select Tools -> Board -> Board Managers ... . This will open the Boards Manager dialog. In the search field, type ATTinyCore(Debug enabled) and install the most recent version. Afterward, do the same with MiniCore and MicroCore . Check: Select Tools -> Board -> ATtinyCore (Debug enabled) -> Attiny25/45/85 (no bootloader) . The debug button in the upper row (3rd from the left) is no longer greyed out.","title":"Step 2: Install new board manager files"},{"location":"quickstart-AVR-GDB/#step-3-install-dw-link-firmware","text":"First, connect the UNO to your computer using the USB cable. Make sure that you have the permission to access the serial interface (under Linux). The simplest way to install the firmware is to download an uploader from the Release assets of the GitHub repo . The uploader should fit your architecture, e.g., dw-uploader-windows-intel64 for Windows. Under Linux and macOS , open a terminal window, go to the download folder, and set the executable permission using chmod +x . Afterward, execute the program. Under Windows , it is enough to start the program after downloading by double-clicking on it. Alternatively, you can download or clone the dw-link repository and then compile and upload the dw-link Arduino sketch using the Arduino IDE 2. Check: Open the Serial Monitor (under the Tools menu), choose 115200 baud , type - (minus sign) into the upper line, and send it. The hardware debugger should respond with $#00 .","title":"Step 3: Install dw-link firmware"},{"location":"quickstart-AVR-GDB/#step-4-install-avr-gdb-on-the-host-computer","text":"The installation of the board definition files will lead to the download of a recent version of the GDB debug client in the tools section of the respective package. You should be able to copy it to a place in your PATH , e.g., /usr/local/bin . On a Mac: ~/Library/Arduino15/packages/MiniCore/tools/avrocd-tools/XXX/avr-gdb Under Linux : ~/.arduino15/packages/MiniCore/tools/avrocd-tools/XXX/avr-gdb Under Windows: C:\\Users\\\\{username}\\AppData\\Local\\Arduino15\\packages\\MiniCore\\tools\\avrocd-tools\\XXX\\avr-gdb.exe If the file is not there, you can install it from other sources, as described below.","title":"Step 4: Install avr-gdb on the host computer"},{"location":"quickstart-AVR-GDB/#on-a-mac","text":"If you have not done so, you must install the package manager Homebrew first. Go to https://brew.sh/ and follow the instructions. Installing Homebrew can take some considerable time. After that, you can install avr-gdb, the host debug client, by typing the following line into a shell: brew tap osx-cross/avr && brew install avr-gdb","title":"On a Mac:"},{"location":"quickstart-AVR-GDB/#under-linux","text":"You can install avr-gdb using the appropriate packet manager. For Debian/Ubuntu, that looks as follows (note that the package is indeed named gdb-avr): sudo apt-get install gdb-avr","title":"Under Linux:"},{"location":"quickstart-AVR-GDB/#under-windows","text":"The easiest way to get hold of avr-gdb is probably to download the avr-gcc toolchain from Zak's blog: https://blog.zakkemble.net/avr-gcc-builds/. Then unzip and copy /bin/avr-gdb to some place, e.g., C:\\Progam Files\\bin\\ . Afterward, you should put this path into the Windows PATH variable. This means you type System into the search field on the control panel, click on Advanced Settings , click on Environment Variables , and then add C:\\Progam Files\\bin to the PATH environment variable. Check: Open a terminal window and type avr-gdb . This should start the debugger, which you can quit by typing quit .","title":"Under Windows:"},{"location":"quickstart-AVR-GDB/#step-5-hardware-setup","text":"This description is for debugging an ATtiny85. However, almost any other classic ATtiny or ATmegaX8 would do. Just be aware that when trying to debug an Arduino Uno board, you need to alter the board physically (cut a solder bridge). How to set up an Uno as a target board is described in the dw-link manual . You need to set up the hardware on a breadboard and use six wires to connect the ATtiny to your Uno, turned into a hardware debugger. Note that the notch or dot on the ATtiny is oriented towards the left. Note that the notch or dot on the ATtiny is oriented towards the left. Here is a table of all the connections so that you can check that you have made all the connections. ATtiny pin# Arduino Uno pin component 1 (Reset) D8 10k resistor to Vcc 2 (D3) 3 (D4) 220 \u03a9 resistor to target (red) LED (+) 4 (GND) GND red and yellow LED (-), decoupling cap 100 nF, RESET blocking cap of 10\u00b5F (-) 5 (D0, MOSI) D11 6 (D1, MISO) D12 7 (D2, SCK) D13 8 (Vcc) 5V 10k resistor, decoupling cap 100 nF RESET RESET blocking cap of 10 \u00b5F (+) D7 220 \u03a9 to system (yellow) LED (+) The yellow LED is the system LED , and the red one is the ATtiny-LED . The system LED gives you information about the internal state of the debugger: debugWIRE mode disabled (LED is off), waiting for power-cycling the target (LED flashes every second for 0.1 sec),3. debugWIRE mode enabled (LED is on), ISP programming (LED is blinking slowly), error state, i.e., not possible to connect to target or internal error (LED blinks furiously every 0.1 sec). Check: Go through the table above and check every connection. Wrong wiring can often cause hours of useless software debugging!","title":"Step 5: Hardware setup"},{"location":"quickstart-AVR-GDB/#step-6-compiling-the-arduino-sketch-for-the-target","text":"Either you use the arduino-cli to compile your sketch (and then I assume you know what you are doing), or you use the IDE: Load the sketch, you want to debug (e.g., dw-link-x.y.z/examples/varblink/varblink.ino ) into the IDE and select ATtiny25/45/85 (no bootloader) as the board. As Clock Source choose 1 MHz (internal) (assuming that the ATtiny is as it comes from the factory and no fuse has been changed). In the Sketch menu, you should now activate `Optimize for Debugging. When you now select Sketch -> Export compiled Binary , then the sketch will be compiled and an ELF file (a binary that contains debugging information) is placed into the folder build/<board-type>/ inside the sketch folder. You can also use arduino-cli to compile the sketch. Make sure to set the compiler option -Og , which makes sure that the compiler optimized for debugging (instead of for space). Check: Open terminal window and change into the sketch folder. The ELF file <sketchname>.ino.elf should either be in the the sketch folder or in a subdirectory of the build folder.","title":"Step 6: Compiling the Arduino sketch for the target"},{"location":"quickstart-AVR-GDB/#step-7-debugging","text":"Now, we are ready to debug the sketch on the target chip. Check that the host , the computer you are sitting at, is connected to the hardware debugger , the Uno, with a USB cable. The hardware debugger should in turn be connected to the target chip, the ATtiny85, by 6 flying wires as we have prepared it in step 5. Open a terminal window and change into the folder where the ELF file resides. Then type avr-gdb -b 115200 <sketchname>.ino.elf where \\<sketchname> is the name of the Arduino sketch. This should fire up the avr-gdb debugger, which will prompt you with (gdb) . When you now type (gdb) target remote <serial-port> where \\<serial-port> is the serial port of the Uno, then, after a few seconds, one should get a message similar to the following one Remote debugging using <serial-port> 0x00000000 in __vectors () You are connected to the hardware debugger. Now you need to enable the debugWIRE mode: (gdb) monitor debugWIRE enable This will bring up the message *** Please power-cycle target *** asking you to switch power to the target off and the on again in order to acxtivate debugWIRE mode. If in repsonse to it, the following message appears Connected to ATmega328P debugWIRE is enabled, bps: 125244 and the system LED lights up, then you are in business! What else could happen? If the LED stays dark and you receive the message /dev/XXXXXXXX: Resource busy , then some other program is currently accessing the serial port. Perhaps there is still a monitor window open? Close that and try again. If the LED stays dark and you got the message Ignoring packet error, continuing... when trying to connect, then the hardware debugger could not be reached over the serial connection. Perhaps, wrong baud rate? If the LED is instead blinking quickly, then the hardware debugger could not connect to the target. Type monitor info , which should give you the reason. Probably: Wrong wiring. So check the wiring or maybe try a different MCU. Assuming that everything went according to plan, the only thing missing now is that the sketch is loaded into flash memory. But the next command will exactly do this: load After a while, the debugger will then tell you Loading section .text, size 0x714 lma 0x0 Loading section .data, size 0x4 lma 0x714 Start address 0x00000000, load size 1816 Transfer rate: 618 bytes/sec, 113 bytes/write. or something similar. Now, you really can get into it! Here is a short list of commands that are useful: l - list program text around current point and advances point l fn - list function fn b fn - puts a breakpoint at the beginning of function fn b num - puts a breakpoint at line num in current file i b - list breakpoints d num - deletes breakpoint number num c - continues running the program until the next breakpoint or stop by CTRL-C s - runs the next line of the program s num - run the next num lines of the program n - like s, but it does not step into functions monitor reset - resets MCUs and sets program counter to 0 bt - print the call stack p var - prints the current value of the variable var set variable var =*expr - sets var to new value expr* q - quits gdb CTRL-C while the programming is running stops the execution asynchronously There are tons of GDB commands, too many to show here! On the documentation page of GDB , you find an extensive manual and a useful PDF reference sheet . A list of monitor commands , which are specific to the dw-link debugger, can be found in the dw-link manual.","title":"Step 7: Debugging"},{"location":"quickstart-AVR-GDB/#after-debugging","text":"When you are done with debugging, you probably want to disable the debugWIRE mode again, because in debugWIRE mode, you cannot use the RESET line or ISP programming. This can be accomplished by using the command monitor debugwire disable before you leave the debugger. After debugging, you can still can use dw-link as a programmer (of type Arduino as ISP ). It is not the fastest one, but if you do not have anything better, it will do its job. If you want a more durable hardware debugging solution, there are some suggestions in the dw-link manual. These days, however, the Microchip debugger MPLAP SNAP might be a better deal. You can use it as a drop-in replacement for dw-link; it costs less than US-$15, and it is able to do much more!","title":"After debugging"},{"location":"quickstart-AVR-GDB/#what-can-go-wrong","text":"First, the dw-link firmware upload may fail. If so, try to use the conventional way by downloading the latest release version and then compiling and uploading the dw-link sketch. Second, if something does not work as advertised, it is often a simple wiring problem. Other possible sources of errors are installation errors, i.e., that a program is not installed at the right place, does not have the proper permissions, the PATH variable is incorrect, or one has installed the wrong board manager files. When some strange error messages show up, it may also indicate that some components have not been installed. Google for the error message! Often, there are hints on how to mitigate the problem. Finally, there is also a troubleshooting section in the dw-link manual, which may be helpful. The most annoying problem can be that an MCU might not be responsive anymore after a debugging session. The reason is that the RESET line, which is used as a communication line during debugging, has not been re-enabled. While a regular exit of the debugger restores the RESET line, the debugger may be terminated without restoring it. An easy cure is to enter the debugger again and leave it regularly (after connecting to the target chip) with the command quit . If this does not help, you may have to use a High-Voltage programmer, such as RescueAVR . If you think you have found a bug, please post it on issues .","title":"What can go wrong?"},{"location":"quickstart-Arduino-IDE2/","text":"Quick-start guide: Debugging with the Arduino IDE 2 You can turn your Arduino Uno into a hardware debugger that can be used for embedded debugging of classic AVR chips under Arduino IDE 2 . If you want to debug your classic AVR chips without using Arduino IDE 2, consult the alternative quickstart guide for AVR-GDB debugging . What you need Computer running Windows, macOS, or Linux (the host ) Arduino Uno (will become the hardware debugger ) USB cable ATtiny85 (or any other classic ATtiny or ATmegaX8) as the target In order to connect the hardware debugger to the target, you need: a breadboard together with 11 Jumper wires (male-to-male) 2 LEDs 3 Resistors (10 k\u03a9, 220\u03a9, 220\u03a9) 2 Capacitors (100 nF, 10 \u00b5F) Step 1: Install Arduino IDE 2 You probably already have the Arduino IDE 2 installed. If not, download and install it from https://arduino.cc. Check: Start IDE and check the About Arduino entry under the Arduino or Help menu for the version number. It should be >= 2.3.0. Step 2: Install new board manager files Open the Preferences dialog of the Arduino IDE and paste the following Board Manager URLs into the list: https://downloads.pyavrocd.io/package_debug_enabled_index.json https://mcudude.github.io/MiniCore/package_MCUdude_MiniCore_index.json https://mcudude.github.io/MicroCore/package_MCUdude_MicroCore_index.json Close the Preference dialog with OK . Now, you can install the cores, ATTinyCore (Debug enabled) , MiniCore , and MicroCore . Select Tools -> Board -> Board Managers ... . This will open the Boards Manager dialog. In the search field, type ATTinyCore (Debug enabled) and install the most recent version. Check: Select Tools -> Board -> ATtinyCore Debug enabled) -> Attiny25/45/85 (no bootloader) . The debug button in the upper row (3rd from the left) is no longer greyed out. Step 3: Install dw-link firmware on an Uno First, connect the UNO to your computer using the USB cable. Make sure that you have the permission to access the serial interface (under Linux). The simplest way to install the firmware is to download an uploader from the Release assets of the GitHub repo . The uploader should fit your architecture, e.g., dw-uploader-windows-intel64 for Windows. Under Linux and macOS , open a terminal window, go to the download folder, and set the executable permission using chmod +x . Afterward, execute the program. Under Windows , it is enough to start the program after downloading by double-clicking on it. Alternatively, you can download or clone the dw-link repository and then compile and upload the dw-link Arduino sketch using the Arduino IDE 2. Check: Open the Serial Monitor (under the Tools menu), choose 115200 baud , type - (minus sign) into the upper line, and send it. The hardware debugger should respond with $#00 . Step 4: Hardware setup This description is for debugging an ATtiny85. However, almost any other classic ATtiny or ATmegaX8 would do. Just be aware that when trying to debug an Arduino Uno board, you need to alter the board physically (cut a solder bridge). How to set up an Uno as a target board is described in the Hardware setup section . You need to set up the hardware on a breadboard and use six wires to connect the ATtiny to your Uno, turned into a hardware debugger. Note that the notch or dot on the ATtiny is oriented towards the left. Here is a table of all connections to check that you have made all the connections. ATtiny pin# Arduino Uno pin component 1 (Reset) D8 10k resistor to Vcc 2 (D3) 3 (D4) 220 \u03a9 resistor to target (red) LED (+) 4 (GND) GND red and yellow LED (-), decoupling cap 100 nF, RESET blocking cap of 10\u00b5F (-) 5 (D0, MOSI) D11 6 (D1, MISO) D12 7 (D2, SCK) D13 8 (Vcc) 5V 10k resistor, decoupling cap 100 nF RESET RESET blocking cap of 10 \u00b5F (+) D7 220 \u03a9 to system (yellow) LED (+) The yellow LED is the system LED , and the red one is the ATtiny-LED . The system LED gives you information about the internal state of the debugger: debugWIRE mode disabled (LED is off), waiting for power-cycling the target (LED flashes every second for 0.1 sec) debugWIRE mode enabled (LED is on), ISP programming (LED is blinking slowly), error state, i.e., not possible to connect to target or internal error (LED blinks furiously every 0.1 sec). Check: Go through the table above and check every connection. Wrong wiring can often cause hours of useless software debugging! Step 5: Start Debugging Load the sketch you want to debug (e.g., dw-link-x.y.z/examples/varblink/varblink.ino ) into the IDE by choosing Open... in the File menu. Select ATtiny25/45/85 (no bootloader) as the board under Tools -> Board -> ATTinyCore . In the Tools menu, choose 1 MHz (internal) as the Clock Source (assuming that the ATtiny is as it comes from the factory and no fuse has been changed). In the Sketch menu, select Optimize for Debugging . Compile the code by clicking the Verify button in the upper left corner. Open the debug panes by clicking the debug symbol (bug with triangle) in the left sidebar. Click the debug symbol in the top row to start debugging. This will start the debugger and the debug server. The activities are logged in the Debug Console and the gdb-server console in the bottom right part of the window. You will probably be asked to \"power-cycle the target.\" This means that you need to remove power from the target and then reconnect it, activating the debugWIRE mode. After the debugger and gdb-server have been started, the debugger will start executing the program on the target. Execution will stop at the first line of the setup function. Now, you are in business and can set breakpoints (clicking left of the line number), continue executing, stop the program asynchronously, inspect and change values, and examine different stack frames. To terminate your debugging session, click the red box in the debug row before terminating the debugging session. Be aware that after finishing the debug session, the MCU is still in debugWIRE mode! You can change that by typing monitor debugwire disable in the last line of the Debug Console . More information can be found in the dw-link manual . After debugging has finished When you are done with debugging, you probably want to disable the debugWIRE mode again, because in debugWIRE mode, you cannot use the RESET line or ISP programming. This can be accomplished by using the command monitor debugwire disable before you leave the debugger. So, after everything has been debugged, what do you do with your newly built hardware debugger? You don't have to throw it away. You can also use it as an ISP programmer (STK500 v1). In the Arduino IDE, such a programmer is called Arduino as ISP . If you want a more durable hardware debugging solution, there are some suggestions in the dw-link manual. These days, however, the Microchip debugger MPLAP SNAP might be a better deal. You can use it as a drop-in replacement for dw-link; it costs less than US-$15, and it is able to do much more! What can go wrong? First, the dw-link firmware upload may fail. If so, try to use the conventional way by downloading the latest release version and then compiling and uploading the dw-link sketch. Second, you might be unable to start debugging because the debug button is greyed out. This happens for all MCUs that the IDE cannot debug. If you think that this is an error, you might need to install the correct board definition files or choose the Reload Board Data entry in the Tools menu. Third, the debug server might terminate early. In this case, you should see an error message in the gdb-server console. If something does not work as advertised, it is often a simple wiring problem. Other possible sources of errors are installation errors, i.e., that a program is not installed at the right place, does not have the proper permissions, the PATH variable is incorrect, or one has installed the wrong board manager files. When strange error messages appear, it may also indicate that some components have not been installed. Google for the error message! Often, there are hints on how to mitigate the problem. Finally, there is also a troubleshooting section in the dw-link manual, which may be helpful. The most annoying problem is that an MCU might not be responsive after a debugging session. The reason is that the RESET line, which is used as a communication line during debugging, has not been re-enabled. The command monitor debugwire disable typed into the last line of the Debug Console just before terminating the debugger should restore the RESET line functionality. If this does not help, you may have to use a High-Voltage programmer, such as RescueAVR . If you have found a bug, please post it on issues .","title":"Arduino IDE 2"},{"location":"quickstart-Arduino-IDE2/#quick-start-guide-debugging-with-the-arduino-ide-2","text":"You can turn your Arduino Uno into a hardware debugger that can be used for embedded debugging of classic AVR chips under Arduino IDE 2 . If you want to debug your classic AVR chips without using Arduino IDE 2, consult the alternative quickstart guide for AVR-GDB debugging .","title":"Quick-start guide: Debugging with the Arduino IDE 2"},{"location":"quickstart-Arduino-IDE2/#what-you-need","text":"Computer running Windows, macOS, or Linux (the host ) Arduino Uno (will become the hardware debugger ) USB cable ATtiny85 (or any other classic ATtiny or ATmegaX8) as the target In order to connect the hardware debugger to the target, you need: a breadboard together with 11 Jumper wires (male-to-male) 2 LEDs 3 Resistors (10 k\u03a9, 220\u03a9, 220\u03a9) 2 Capacitors (100 nF, 10 \u00b5F)","title":"What you need"},{"location":"quickstart-Arduino-IDE2/#step-1-install-arduino-ide-2","text":"You probably already have the Arduino IDE 2 installed. If not, download and install it from https://arduino.cc. Check: Start IDE and check the About Arduino entry under the Arduino or Help menu for the version number. It should be >= 2.3.0.","title":"Step 1: Install Arduino IDE 2"},{"location":"quickstart-Arduino-IDE2/#step-2-install-new-board-manager-files","text":"Open the Preferences dialog of the Arduino IDE and paste the following Board Manager URLs into the list: https://downloads.pyavrocd.io/package_debug_enabled_index.json https://mcudude.github.io/MiniCore/package_MCUdude_MiniCore_index.json https://mcudude.github.io/MicroCore/package_MCUdude_MicroCore_index.json Close the Preference dialog with OK . Now, you can install the cores, ATTinyCore (Debug enabled) , MiniCore , and MicroCore . Select Tools -> Board -> Board Managers ... . This will open the Boards Manager dialog. In the search field, type ATTinyCore (Debug enabled) and install the most recent version. Check: Select Tools -> Board -> ATtinyCore Debug enabled) -> Attiny25/45/85 (no bootloader) . The debug button in the upper row (3rd from the left) is no longer greyed out.","title":"Step 2: Install new board manager files"},{"location":"quickstart-Arduino-IDE2/#step-3-install-dw-link-firmware-on-an-uno","text":"First, connect the UNO to your computer using the USB cable. Make sure that you have the permission to access the serial interface (under Linux). The simplest way to install the firmware is to download an uploader from the Release assets of the GitHub repo . The uploader should fit your architecture, e.g., dw-uploader-windows-intel64 for Windows. Under Linux and macOS , open a terminal window, go to the download folder, and set the executable permission using chmod +x . Afterward, execute the program. Under Windows , it is enough to start the program after downloading by double-clicking on it. Alternatively, you can download or clone the dw-link repository and then compile and upload the dw-link Arduino sketch using the Arduino IDE 2. Check: Open the Serial Monitor (under the Tools menu), choose 115200 baud , type - (minus sign) into the upper line, and send it. The hardware debugger should respond with $#00 .","title":"Step 3: Install dw-link firmware on an Uno"},{"location":"quickstart-Arduino-IDE2/#step-4-hardware-setup","text":"This description is for debugging an ATtiny85. However, almost any other classic ATtiny or ATmegaX8 would do. Just be aware that when trying to debug an Arduino Uno board, you need to alter the board physically (cut a solder bridge). How to set up an Uno as a target board is described in the Hardware setup section . You need to set up the hardware on a breadboard and use six wires to connect the ATtiny to your Uno, turned into a hardware debugger. Note that the notch or dot on the ATtiny is oriented towards the left. Here is a table of all connections to check that you have made all the connections. ATtiny pin# Arduino Uno pin component 1 (Reset) D8 10k resistor to Vcc 2 (D3) 3 (D4) 220 \u03a9 resistor to target (red) LED (+) 4 (GND) GND red and yellow LED (-), decoupling cap 100 nF, RESET blocking cap of 10\u00b5F (-) 5 (D0, MOSI) D11 6 (D1, MISO) D12 7 (D2, SCK) D13 8 (Vcc) 5V 10k resistor, decoupling cap 100 nF RESET RESET blocking cap of 10 \u00b5F (+) D7 220 \u03a9 to system (yellow) LED (+) The yellow LED is the system LED , and the red one is the ATtiny-LED . The system LED gives you information about the internal state of the debugger: debugWIRE mode disabled (LED is off), waiting for power-cycling the target (LED flashes every second for 0.1 sec) debugWIRE mode enabled (LED is on), ISP programming (LED is blinking slowly), error state, i.e., not possible to connect to target or internal error (LED blinks furiously every 0.1 sec). Check: Go through the table above and check every connection. Wrong wiring can often cause hours of useless software debugging!","title":"Step 4: Hardware setup"},{"location":"quickstart-Arduino-IDE2/#step-5-start-debugging","text":"Load the sketch you want to debug (e.g., dw-link-x.y.z/examples/varblink/varblink.ino ) into the IDE by choosing Open... in the File menu. Select ATtiny25/45/85 (no bootloader) as the board under Tools -> Board -> ATTinyCore . In the Tools menu, choose 1 MHz (internal) as the Clock Source (assuming that the ATtiny is as it comes from the factory and no fuse has been changed). In the Sketch menu, select Optimize for Debugging . Compile the code by clicking the Verify button in the upper left corner. Open the debug panes by clicking the debug symbol (bug with triangle) in the left sidebar. Click the debug symbol in the top row to start debugging. This will start the debugger and the debug server. The activities are logged in the Debug Console and the gdb-server console in the bottom right part of the window. You will probably be asked to \"power-cycle the target.\" This means that you need to remove power from the target and then reconnect it, activating the debugWIRE mode. After the debugger and gdb-server have been started, the debugger will start executing the program on the target. Execution will stop at the first line of the setup function. Now, you are in business and can set breakpoints (clicking left of the line number), continue executing, stop the program asynchronously, inspect and change values, and examine different stack frames. To terminate your debugging session, click the red box in the debug row before terminating the debugging session. Be aware that after finishing the debug session, the MCU is still in debugWIRE mode! You can change that by typing monitor debugwire disable in the last line of the Debug Console . More information can be found in the dw-link manual .","title":"Step 5: Start Debugging"},{"location":"quickstart-Arduino-IDE2/#after-debugging-has-finished","text":"When you are done with debugging, you probably want to disable the debugWIRE mode again, because in debugWIRE mode, you cannot use the RESET line or ISP programming. This can be accomplished by using the command monitor debugwire disable before you leave the debugger. So, after everything has been debugged, what do you do with your newly built hardware debugger? You don't have to throw it away. You can also use it as an ISP programmer (STK500 v1). In the Arduino IDE, such a programmer is called Arduino as ISP . If you want a more durable hardware debugging solution, there are some suggestions in the dw-link manual. These days, however, the Microchip debugger MPLAP SNAP might be a better deal. You can use it as a drop-in replacement for dw-link; it costs less than US-$15, and it is able to do much more!","title":"After debugging has finished"},{"location":"quickstart-Arduino-IDE2/#what-can-go-wrong","text":"First, the dw-link firmware upload may fail. If so, try to use the conventional way by downloading the latest release version and then compiling and uploading the dw-link sketch. Second, you might be unable to start debugging because the debug button is greyed out. This happens for all MCUs that the IDE cannot debug. If you think that this is an error, you might need to install the correct board definition files or choose the Reload Board Data entry in the Tools menu. Third, the debug server might terminate early. In this case, you should see an error message in the gdb-server console. If something does not work as advertised, it is often a simple wiring problem. Other possible sources of errors are installation errors, i.e., that a program is not installed at the right place, does not have the proper permissions, the PATH variable is incorrect, or one has installed the wrong board manager files. When strange error messages appear, it may also indicate that some components have not been installed. Google for the error message! Often, there are hints on how to mitigate the problem. Finally, there is also a troubleshooting section in the dw-link manual, which may be helpful. The most annoying problem is that an MCU might not be responsive after a debugging session. The reason is that the RESET line, which is used as a communication line during debugging, has not been re-enabled. The command monitor debugwire disable typed into the last line of the Debug Console just before terminating the debugger should restore the RESET line functionality. If this does not help, you may have to use a High-Voltage programmer, such as RescueAVR . If you have found a bug, please post it on issues .","title":"What can go wrong?"},{"location":"quickstart/","text":"Quick-start guide: Debugging with the Arduino IDE 2 You can turn your Arduino Uno into a hardware debugger that can be used for embedded debugging of classic AVR chips under Arduino IDE 2 . If you want to debug your classic AVR chips without using Arduino IDE 2, consult the alternative quickstart guide for AVR-GDB debugging . What you need Computer running Windows, macOS, or Linux (the host ) Arduino Uno (will become the hardware debugger ) USB cable ATtiny85 (or any other classic ATtiny or ATmegaX8) as the target In order to connect the hardware debugger to the target, you need: a breadboard together with 11 Jumper wires (male-to-male) 2 LEDs 3 Resistors (10 k\u03a9, 220\u03a9, 220\u03a9) 2 Capacitors (100 nF, 10 \u00b5F) Step 1: Install Arduino IDE 2 You probably already have the Arduino IDE 2 installed. If not, download and install it from https://arduino.cc. Check: Start IDE and check the About Arduino entry under the Arduino or Help menu for the version number. It should be >= 2.3.0. Step 2: Install new board manager files Open the Preferences dialog of the Arduino IDE and paste the following Board Manager URLs into the list: https://downloads.pyavrocd.io/package_debug_enabled_index.json https://mcudude.github.io/MiniCore/package_MCUdude_MiniCore_index.json https://mcudude.github.io/MicroCore/package_MCUdude_MicroCore_index.json Close the Preference dialog with OK . Now, you can install the cores, ATTinyCore (Debug enabled) , MiniCore , and MicroCore . Select Tools -> Board -> Board Managers ... . This will open the Boards Manager dialog. In the search field, type ATTinyCore (Debug enabled) and install the most recent version. Check: Select Tools -> Board -> ATtinyCore Debug enabled) -> Attiny25/45/85 (no bootloader) . The debug button in the upper row (3rd from the left) is no longer greyed out. Step 3: Install dw-link firmware on an Uno First, connect the UNO to your computer using the USB cable. Make sure that you have the permission to access the serial interface (under Linux). The simplest way to install the firmware is to download an uploader from the Release assets of the GitHub repo . The uploader should fit your architecture, e.g., dw-uploader-windows-intel64 for Windows. Under Linux and macOS , open a terminal window, go to the download folder, and set the executable permission using chmod +x . Afterward, execute the program. Under Windows , it is enough to start the program after downloading by double-clicking on it. Alternatively, you can download or clone the dw-link repository and then compile and upload the dw-link Arduino sketch using the Arduino IDE 2. Check: Open the Serial Monitor (under the Tools menu), choose 115200 baud , type - (minus sign) into the upper line, and send it. The hardware debugger should respond with $#00 . Step 4: Hardware setup This description is for debugging an ATtiny85. However, almost any other classic ATtiny or ATmegaX8 would do. Just be aware that when trying to debug an Arduino Uno board, you need to alter the board physically (cut a solder bridge). How to set up an Uno as a target board is described in the Hardware setup section . You need to set up the hardware on a breadboard and use six wires to connect the ATtiny to your Uno, turned into a hardware debugger. Note that the notch or dot on the ATtiny is oriented towards the left. Here is a table of all connections to check that you have made all the connections. ATtiny pin# Arduino Uno pin component 1 (Reset) D8 10k resistor to Vcc 2 (D3) 3 (D4) 220 \u03a9 resistor to target (red) LED (+) 4 (GND) GND red and yellow LED (-), decoupling cap 100 nF, RESET blocking cap of 10\u00b5F (-) 5 (D0, MOSI) D11 6 (D1, MISO) D12 7 (D2, SCK) D13 8 (Vcc) 5V 10k resistor, decoupling cap 100 nF RESET RESET blocking cap of 10 \u00b5F (+) D7 220 \u03a9 to system (yellow) LED (+) The yellow LED is the system LED , and the red one is the ATtiny-LED . The system LED gives you information about the internal state of the debugger: debugWIRE mode disabled (LED is off), waiting for power-cycling the target (LED flashes every second for 0.1 sec) debugWIRE mode enabled (LED is on), ISP programming (LED is blinking slowly), error state, i.e., not possible to connect to target or internal error (LED blinks furiously every 0.1 sec). Check: Go through the table above and check every connection. Wrong wiring can often cause hours of useless software debugging! Step 5: Start Debugging Load the sketch you want to debug (e.g., dw-link-x.y.z/examples/varblink/varblink.ino ) into the IDE by choosing Open... in the File menu. Select ATtiny25/45/85 (no bootloader) as the board under Tools -> Board -> ATTinyCore . In the Tools menu, choose 1 MHz (internal) as the Clock Source (assuming that the ATtiny is as it comes from the factory and no fuse has been changed). In the Sketch menu, select Optimize for Debugging . Compile the code by clicking the Verify button in the upper left corner. Open the debug panes by clicking the debug symbol (bug with triangle) in the left sidebar. Click the debug symbol in the top row to start debugging. This will start the debugger and the debug server. The activities are logged in the Debug Console and the gdb-server console in the bottom right part of the window. You will probably be asked to \"power-cycle the target.\" This means that you need to remove power from the target and then reconnect it, activating the debugWIRE mode. After the debugger and gdb-server have been started, the debugger will start executing the program on the target. Execution will stop at the first line of the setup function. Now, you are in business and can set breakpoints (clicking left of the line number), continue executing, stop the program asynchronously, inspect and change values, and examine different stack frames. To terminate your debugging session, click the red box in the debug row before terminating the debugging session. Be aware that after finishing the debug session, the MCU is still in debugWIRE mode! You can change that by typing monitor debugwire disable in the last line of the Debug Console . More information can be found in the dw-link manual . After debugging has finished When you are done with debugging, you probably want to disable the debugWIRE mode again, because in debugWIRE mode, you cannot use the RESET line or ISP programming. This can be accomplished by using the command monitor debugwire disable before you leave the debugger. So, after everything has been debugged, what do you do with your newly built hardware debugger? You don't have to throw it away. You can also use it as an ISP programmer (STK500 v1). In the Arduino IDE, such a programmer is called Arduino as ISP . If you want a more durable hardware debugging solution, there are some suggestions in the dw-link manual. These days, however, the Microchip debugger MPLAP SNAP might be a better deal. You can use it as a drop-in replacement for dw-link; it costs less than US-$15, and it is able to do much more! What can go wrong? First, the dw-link firmware upload may fail. If so, try to use the conventional way by downloading the latest release version and then compiling and uploading the dw-link sketch. Second, you might be unable to start debugging because the debug button is greyed out. This happens for all MCUs that the IDE cannot debug. If you think that this is an error, you might need to install the correct board definition files or choose the Reload Board Data entry in the Tools menu. Third, the debug server might terminate early. In this case, you should see an error message in the gdb-server console. If something does not work as advertised, it is often a simple wiring problem. Other possible sources of errors are installation errors, i.e., that a program is not installed at the right place, does not have the proper permissions, the PATH variable is incorrect, or one has installed the wrong board manager files. When strange error messages appear, it may also indicate that some components have not been installed. Google for the error message! Often, there are hints on how to mitigate the problem. Finally, there is also a troubleshooting section in the dw-link manual, which may be helpful. The most annoying problem is that an MCU might not be responsive after a debugging session. The reason is that the RESET line, which is used as a communication line during debugging, has not been re-enabled. The command monitor debugwire disable typed into the last line of the Debug Console just before terminating the debugger should restore the RESET line functionality. If this does not help, you may have to use a High-Voltage programmer, such as RescueAVR . If you have found a bug, please post it on issues .","title":"Quick-start guide: Debugging with the Arduino IDE 2"},{"location":"quickstart/#quick-start-guide-debugging-with-the-arduino-ide-2","text":"You can turn your Arduino Uno into a hardware debugger that can be used for embedded debugging of classic AVR chips under Arduino IDE 2 . If you want to debug your classic AVR chips without using Arduino IDE 2, consult the alternative quickstart guide for AVR-GDB debugging .","title":"Quick-start guide: Debugging with the Arduino IDE 2"},{"location":"quickstart/#what-you-need","text":"Computer running Windows, macOS, or Linux (the host ) Arduino Uno (will become the hardware debugger ) USB cable ATtiny85 (or any other classic ATtiny or ATmegaX8) as the target In order to connect the hardware debugger to the target, you need: a breadboard together with 11 Jumper wires (male-to-male) 2 LEDs 3 Resistors (10 k\u03a9, 220\u03a9, 220\u03a9) 2 Capacitors (100 nF, 10 \u00b5F)","title":"What you need"},{"location":"quickstart/#step-1-install-arduino-ide-2","text":"You probably already have the Arduino IDE 2 installed. If not, download and install it from https://arduino.cc. Check: Start IDE and check the About Arduino entry under the Arduino or Help menu for the version number. It should be >= 2.3.0.","title":"Step 1: Install Arduino IDE 2"},{"location":"quickstart/#step-2-install-new-board-manager-files","text":"Open the Preferences dialog of the Arduino IDE and paste the following Board Manager URLs into the list: https://downloads.pyavrocd.io/package_debug_enabled_index.json https://mcudude.github.io/MiniCore/package_MCUdude_MiniCore_index.json https://mcudude.github.io/MicroCore/package_MCUdude_MicroCore_index.json Close the Preference dialog with OK . Now, you can install the cores, ATTinyCore (Debug enabled) , MiniCore , and MicroCore . Select Tools -> Board -> Board Managers ... . This will open the Boards Manager dialog. In the search field, type ATTinyCore (Debug enabled) and install the most recent version. Check: Select Tools -> Board -> ATtinyCore Debug enabled) -> Attiny25/45/85 (no bootloader) . The debug button in the upper row (3rd from the left) is no longer greyed out.","title":"Step 2: Install new board manager files"},{"location":"quickstart/#step-3-install-dw-link-firmware-on-an-uno","text":"First, connect the UNO to your computer using the USB cable. Make sure that you have the permission to access the serial interface (under Linux). The simplest way to install the firmware is to download an uploader from the Release assets of the GitHub repo . The uploader should fit your architecture, e.g., dw-uploader-windows-intel64 for Windows. Under Linux and macOS , open a terminal window, go to the download folder, and set the executable permission using chmod +x . Afterward, execute the program. Under Windows , it is enough to start the program after downloading by double-clicking on it. Alternatively, you can download or clone the dw-link repository and then compile and upload the dw-link Arduino sketch using the Arduino IDE 2. Check: Open the Serial Monitor (under the Tools menu), choose 115200 baud , type - (minus sign) into the upper line, and send it. The hardware debugger should respond with $#00 .","title":"Step 3: Install dw-link firmware on an Uno"},{"location":"quickstart/#step-4-hardware-setup","text":"This description is for debugging an ATtiny85. However, almost any other classic ATtiny or ATmegaX8 would do. Just be aware that when trying to debug an Arduino Uno board, you need to alter the board physically (cut a solder bridge). How to set up an Uno as a target board is described in the Hardware setup section . You need to set up the hardware on a breadboard and use six wires to connect the ATtiny to your Uno, turned into a hardware debugger. Note that the notch or dot on the ATtiny is oriented towards the left. Here is a table of all connections to check that you have made all the connections. ATtiny pin# Arduino Uno pin component 1 (Reset) D8 10k resistor to Vcc 2 (D3) 3 (D4) 220 \u03a9 resistor to target (red) LED (+) 4 (GND) GND red and yellow LED (-), decoupling cap 100 nF, RESET blocking cap of 10\u00b5F (-) 5 (D0, MOSI) D11 6 (D1, MISO) D12 7 (D2, SCK) D13 8 (Vcc) 5V 10k resistor, decoupling cap 100 nF RESET RESET blocking cap of 10 \u00b5F (+) D7 220 \u03a9 to system (yellow) LED (+) The yellow LED is the system LED , and the red one is the ATtiny-LED . The system LED gives you information about the internal state of the debugger: debugWIRE mode disabled (LED is off), waiting for power-cycling the target (LED flashes every second for 0.1 sec) debugWIRE mode enabled (LED is on), ISP programming (LED is blinking slowly), error state, i.e., not possible to connect to target or internal error (LED blinks furiously every 0.1 sec). Check: Go through the table above and check every connection. Wrong wiring can often cause hours of useless software debugging!","title":"Step 4: Hardware setup"},{"location":"quickstart/#step-5-start-debugging","text":"Load the sketch you want to debug (e.g., dw-link-x.y.z/examples/varblink/varblink.ino ) into the IDE by choosing Open... in the File menu. Select ATtiny25/45/85 (no bootloader) as the board under Tools -> Board -> ATTinyCore . In the Tools menu, choose 1 MHz (internal) as the Clock Source (assuming that the ATtiny is as it comes from the factory and no fuse has been changed). In the Sketch menu, select Optimize for Debugging . Compile the code by clicking the Verify button in the upper left corner. Open the debug panes by clicking the debug symbol (bug with triangle) in the left sidebar. Click the debug symbol in the top row to start debugging. This will start the debugger and the debug server. The activities are logged in the Debug Console and the gdb-server console in the bottom right part of the window. You will probably be asked to \"power-cycle the target.\" This means that you need to remove power from the target and then reconnect it, activating the debugWIRE mode. After the debugger and gdb-server have been started, the debugger will start executing the program on the target. Execution will stop at the first line of the setup function. Now, you are in business and can set breakpoints (clicking left of the line number), continue executing, stop the program asynchronously, inspect and change values, and examine different stack frames. To terminate your debugging session, click the red box in the debug row before terminating the debugging session. Be aware that after finishing the debug session, the MCU is still in debugWIRE mode! You can change that by typing monitor debugwire disable in the last line of the Debug Console . More information can be found in the dw-link manual .","title":"Step 5: Start Debugging"},{"location":"quickstart/#after-debugging-has-finished","text":"When you are done with debugging, you probably want to disable the debugWIRE mode again, because in debugWIRE mode, you cannot use the RESET line or ISP programming. This can be accomplished by using the command monitor debugwire disable before you leave the debugger. So, after everything has been debugged, what do you do with your newly built hardware debugger? You don't have to throw it away. You can also use it as an ISP programmer (STK500 v1). In the Arduino IDE, such a programmer is called Arduino as ISP . If you want a more durable hardware debugging solution, there are some suggestions in the dw-link manual. These days, however, the Microchip debugger MPLAP SNAP might be a better deal. You can use it as a drop-in replacement for dw-link; it costs less than US-$15, and it is able to do much more!","title":"After debugging has finished"},{"location":"quickstart/#what-can-go-wrong","text":"First, the dw-link firmware upload may fail. If so, try to use the conventional way by downloading the latest release version and then compiling and uploading the dw-link sketch. Second, you might be unable to start debugging because the debug button is greyed out. This happens for all MCUs that the IDE cannot debug. If you think that this is an error, you might need to install the correct board definition files or choose the Reload Board Data entry in the Tools menu. Third, the debug server might terminate early. In this case, you should see an error message in the gdb-server console. If something does not work as advertised, it is often a simple wiring problem. Other possible sources of errors are installation errors, i.e., that a program is not installed at the right place, does not have the proper permissions, the PATH variable is incorrect, or one has installed the wrong board manager files. When strange error messages appear, it may also indicate that some components have not been installed. Google for the error message! Often, there are hints on how to mitigate the problem. Finally, there is also a troubleshooting section in the dw-link manual, which may be helpful. The most annoying problem is that an MCU might not be responsive after a debugging session. The reason is that the RESET line, which is used as a communication line during debugging, has not been re-enabled. The command monitor debugwire disable typed into the last line of the Debug Console just before terminating the debugger should restore the RESET line functionality. If this does not help, you may have to use a High-Voltage programmer, such as RescueAVR . If you have found a bug, please post it on issues .","title":"What can go wrong?"},{"location":"requirements/","text":"Hardware requirements There are a few constraints on what kind of board you can use as the base for the hardware debugger and some requirements on how to connect the debugger to the target system. Furthermore, there is only a limited set of AVR MCUs that have a debugWIRE interface. Warning Please read the sections about the RESET line requirements before connecting the debugger to a target system. You might very well \"brick\" your MCU by enabling debugWIRE on a system that does not satisfy these requirements. The hardware debugger As a base for the debugger, in principle one can use any ATmega328 based board. The clock speed must be 16MHz. Currently, the sketch has been tested on the following boards: Arduino UNO , Arduino Nano , Arduino Pro Mini . Be aware of bootloaders Note that the board needs to be flashed with a \"modern\" bootloader, e.g., Optiboot , because dw-link uses the watchdog timers (WDT). Older bootloaders cannot deal with that. The Uno board has this bootloader by default. The bootloaders of older Nanos and those of all Pro Minis need to be updated. Simply burn the UNO bootloader on them and afterward handle them as an UNO. If you intend to use dw-link on a board with an MCU different from ATmega328P, you should know that dw-link makes heavy use of the particular hardware features of the ATmega328P and operates close to the limit. I tried it out on the Leonardo and on the Mega2560, but it was not successful. The most basic setup is to use the UNO board and connect the cables, as shown in the Fritzing sketch in the hardware setup section . If you want to use the debugger more than once, it may pay off to build a modified ISP cable or to use a prototype shield and put an ISP socket on it. The more luxurious solution is a shield for the UNO with level shifters. All these possibilities are described in the section on how to build a better hardware debugger . MCUs with debugWIRE interface In general, almost all \"classic\" ATtiny MCUs and the ATmegaX8 MCU family (which includes the ATmega328P) have the debugWIRE interface. Specifically, the following MCUs that are supported by ATTinyCore , MicroCore and/or by MiniCore can be debugged using this interface: ATtiny13 ATtiny43U ATtiny2313(A) , ATtiny4313 ATtiny24(A) , ATtiny44(A) , ATtiny84(A) ATtiny441 , ATtiny841 ATtiny25 , ATtiny45 , ATtiny85 ATtiny261(A) , ATtiny461(A) , ATtiny861(A) ATtiny87 , ATtiny167 ATtiny828 ATtiny48 , ATtiny88 ATtiny1634 ATmega48 , ATmega48A , ATmega48PA , ATmega48PB, ATmega88 , ATmega88A , ATmega88PA , Atmega88PB, ATmega168 , ATmega168A , ATmega168PA , ATmega168PB, ATmega328 , ATmega328P , ATmega328PB I have tested the debugger on MCUs marked bold. When I tried out the ATmegas that are stroked out, I noticed that they have program counters with some bits stuck at one. For this reason, GDB has problems debugging them. If dw-link discovers stuck-at-one bits, it will report this and refuse to debug such MCUs. Additionally, there exist a few more exotic MCUs, which also have the debugWIRE interface: ATmega8U2, ATmega16U2, ATmega32U2 ATmega32C1, ATmega64C1, ATmega16M1, ATmega32M1, ATmega64M1 AT90USB82, AT90USB162 AT90PWM1, AT90PWM2B, AT90PWM3B AT90PWM81, AT90PWM161 AT90PWM216, AT90PWM316 ATmega8HVA, ATmega16HVA, ATmega16HVB, ATmega32HVA, ATmega32HVB, ATmega64HVE2 The debugger contains code for supporting all listed MCUs. I expect the debugger to work on the supported MCUs. However, there are always surprises . If you can debug such an MCU using dw-link, please drop me a note. Requirements concerning the target system A critical point is the target system's RESET line. Since this line is used as an open-drain , asynchronous half-duplex serial communication line, one has to ensure there is no capacitive load on the line when used in debugWIRE mode. While the debugger tries to recognize such situations before any damage is done, it will certainly not catch all problematic configurations. Further, there should be a pull-up resistor of around 10 k\u03a9. According to reports of other people, 4.7 k\u03a9 might also work. And the RESET line should, of course, not be directly connected to Vcc and there should not be any external reset sources on the RESET line. The debugger does not recognize these problems. If your target system is an Arduino UNO R3 or a similar board, you must be aware that there is a capacitor between the ATmega328's RESET pin and the serial chip's DTR pin that implements the auto-reset feature, as shown in the following picture. One can disconnect the capacitor by cutting the solder bridge labeled RESET EN on the board (see picture), but then you cannot use the automatic reset feature of the Arduino IDE any longer. A recovery method is to put a bit of soldering on the bridge or to solder pins to it that can be shortened by a jumper. On UNO clones, which have a CH340G chip as the serial interface, there is not such a nice cut-off point. On some of them, it is the C8 capacitor that you have to remove. Modifications for other Arduino AVR boards are covered on this webpage . Worst-case scenario So, what is the worst-case scenario when using debugWIRE? As described in the section on debugWIRE , first, the DWEN fuse is programmed using ISP programming. Then, one has to power-cycle to reach the debugWIRE state, where you can communicate with the target over the RESET line. If this kind of communication fails, you cannot put the target back in a state where ISP programming is possible. And the bootloader will not work either because it had to be erased. Your MCU is bricked . One way to try to resurrect your MCU is to make the RESET line compliant with the debugWIRE requirements. Then you should be able to connect to the target using the hardware debugger. The most reliable way to revive your MCU is HV programming, which requires applying 12 volts to the RESET pin and a lot of other things. So you either remove the chip from the board and do the programming offline, or you remove any connection from the RESET line to the Vcc rail and other components on the board. Then, you can use an existing high-voltage programmer or build one on a breadboard .","title":"Hardware requirements"},{"location":"requirements/#hardware-requirements","text":"There are a few constraints on what kind of board you can use as the base for the hardware debugger and some requirements on how to connect the debugger to the target system. Furthermore, there is only a limited set of AVR MCUs that have a debugWIRE interface. Warning Please read the sections about the RESET line requirements before connecting the debugger to a target system. You might very well \"brick\" your MCU by enabling debugWIRE on a system that does not satisfy these requirements.","title":"Hardware requirements"},{"location":"requirements/#the-hardware-debugger","text":"As a base for the debugger, in principle one can use any ATmega328 based board. The clock speed must be 16MHz. Currently, the sketch has been tested on the following boards: Arduino UNO , Arduino Nano , Arduino Pro Mini . Be aware of bootloaders Note that the board needs to be flashed with a \"modern\" bootloader, e.g., Optiboot , because dw-link uses the watchdog timers (WDT). Older bootloaders cannot deal with that. The Uno board has this bootloader by default. The bootloaders of older Nanos and those of all Pro Minis need to be updated. Simply burn the UNO bootloader on them and afterward handle them as an UNO. If you intend to use dw-link on a board with an MCU different from ATmega328P, you should know that dw-link makes heavy use of the particular hardware features of the ATmega328P and operates close to the limit. I tried it out on the Leonardo and on the Mega2560, but it was not successful. The most basic setup is to use the UNO board and connect the cables, as shown in the Fritzing sketch in the hardware setup section . If you want to use the debugger more than once, it may pay off to build a modified ISP cable or to use a prototype shield and put an ISP socket on it. The more luxurious solution is a shield for the UNO with level shifters. All these possibilities are described in the section on how to build a better hardware debugger .","title":"The hardware debugger"},{"location":"requirements/#mcus-with-debugwire-interface","text":"In general, almost all \"classic\" ATtiny MCUs and the ATmegaX8 MCU family (which includes the ATmega328P) have the debugWIRE interface. Specifically, the following MCUs that are supported by ATTinyCore , MicroCore and/or by MiniCore can be debugged using this interface: ATtiny13 ATtiny43U ATtiny2313(A) , ATtiny4313 ATtiny24(A) , ATtiny44(A) , ATtiny84(A) ATtiny441 , ATtiny841 ATtiny25 , ATtiny45 , ATtiny85 ATtiny261(A) , ATtiny461(A) , ATtiny861(A) ATtiny87 , ATtiny167 ATtiny828 ATtiny48 , ATtiny88 ATtiny1634 ATmega48 , ATmega48A , ATmega48PA , ATmega48PB, ATmega88 , ATmega88A , ATmega88PA , Atmega88PB, ATmega168 , ATmega168A , ATmega168PA , ATmega168PB, ATmega328 , ATmega328P , ATmega328PB I have tested the debugger on MCUs marked bold. When I tried out the ATmegas that are stroked out, I noticed that they have program counters with some bits stuck at one. For this reason, GDB has problems debugging them. If dw-link discovers stuck-at-one bits, it will report this and refuse to debug such MCUs. Additionally, there exist a few more exotic MCUs, which also have the debugWIRE interface: ATmega8U2, ATmega16U2, ATmega32U2 ATmega32C1, ATmega64C1, ATmega16M1, ATmega32M1, ATmega64M1 AT90USB82, AT90USB162 AT90PWM1, AT90PWM2B, AT90PWM3B AT90PWM81, AT90PWM161 AT90PWM216, AT90PWM316 ATmega8HVA, ATmega16HVA, ATmega16HVB, ATmega32HVA, ATmega32HVB, ATmega64HVE2 The debugger contains code for supporting all listed MCUs. I expect the debugger to work on the supported MCUs. However, there are always surprises . If you can debug such an MCU using dw-link, please drop me a note.","title":"MCUs with debugWIRE interface"},{"location":"requirements/#requirements-concerning-the-target-system","text":"A critical point is the target system's RESET line. Since this line is used as an open-drain , asynchronous half-duplex serial communication line, one has to ensure there is no capacitive load on the line when used in debugWIRE mode. While the debugger tries to recognize such situations before any damage is done, it will certainly not catch all problematic configurations. Further, there should be a pull-up resistor of around 10 k\u03a9. According to reports of other people, 4.7 k\u03a9 might also work. And the RESET line should, of course, not be directly connected to Vcc and there should not be any external reset sources on the RESET line. The debugger does not recognize these problems. If your target system is an Arduino UNO R3 or a similar board, you must be aware that there is a capacitor between the ATmega328's RESET pin and the serial chip's DTR pin that implements the auto-reset feature, as shown in the following picture. One can disconnect the capacitor by cutting the solder bridge labeled RESET EN on the board (see picture), but then you cannot use the automatic reset feature of the Arduino IDE any longer. A recovery method is to put a bit of soldering on the bridge or to solder pins to it that can be shortened by a jumper. On UNO clones, which have a CH340G chip as the serial interface, there is not such a nice cut-off point. On some of them, it is the C8 capacitor that you have to remove. Modifications for other Arduino AVR boards are covered on this webpage .","title":"Requirements concerning the target system"},{"location":"requirements/#worst-case-scenario","text":"So, what is the worst-case scenario when using debugWIRE? As described in the section on debugWIRE , first, the DWEN fuse is programmed using ISP programming. Then, one has to power-cycle to reach the debugWIRE state, where you can communicate with the target over the RESET line. If this kind of communication fails, you cannot put the target back in a state where ISP programming is possible. And the bootloader will not work either because it had to be erased. Your MCU is bricked . One way to try to resurrect your MCU is to make the RESET line compliant with the debugWIRE requirements. Then you should be able to connect to the target using the hardware debugger. The most reliable way to revive your MCU is HV programming, which requires applying 12 volts to the RESET pin and a lot of other things. So you either remove the chip from the board and do the programming offline, or you remove any connection from the RESET line to the Vcc rail and other components on the board. Then, you can use an existing high-voltage programmer or build one on a breadboard .","title":"Worst-case scenario"},{"location":"setup/","text":"Setting up the hardware Before you can start debugging, you have to set up the hardware. I'll use an ATtiny85 on a breadboard as one example target system. However, any MCU listed above would do as a target. One could even use an Arduino UNO, provided the modifications described in the section on modifying an Uno board have been done. Debugging an ATtiny85 In order to debug an ATtiny85, we will assume it is completely \"naked\" and plugged into a breadboard as shown below. Notice the capacitor of 10 \u00b5F or more between RESET and GND on the UNO board. This will disable the auto-reset of the UNO board. Second, note the yellow LED connected to pin D7. This is the system LED which is used to visualise the internal state of the debugger (see below). You can also build an LED with a series resistor soldered on and then use pins D6 and D7, where D6 is used as GND. GND and Vcc of the ATtiny are connected to the respective lines on the breadboard, which in turn are connected to GND and 5V of the UNO. Pin D8 of the Arduino UNO is connected to the RESET pin of the ATtiny (pin 1). Note the presence of the pull-up resistor of 10k\u03a9 on the ATtiny RESET pin. The remaining connections between Arduino UNO and ATtiny are MOSI (Arduino UNO D11), MISO (Arduino UNO D12), and SCK (Arduino UNO D13), which you need for ISP programming. In addition, there is an LED connected to pin 3 of the ATtiny chip (which is PB4 or pin D4 in Arduino terminology). The pinout of the ATtiny85 is given in the following figure (with the usual \"counter-clockwise\" numbering of Arduino pins). Here is a table of all the connections so that you can check that you have made all the connections. ATtiny pin# Arduino UNO pin component 1 (Reset) D8 10k resistor to Vcc 2 (D3) 3 (D4) 220 \u03a9 resistor to (red) target LED (+) 4 (GND) GND both LED (-), decoupling cap 100 nF, RESET blocking cap of 10\u00b5F (-) 5 (D0, MOSI) D11 6 (D1, MISO) D12 7 (D2, SCK) D13 8 (Vcc) 5V 10k resistor, decoupling cap 100 nF RESET RESET blocking cap of 10 \u00b5F (+) D7 220 \u03a9 resistor to (yellow) system LED (+) Debugging an UNO If you want to debug an UNO board instead of an ATtiny85, everything said above applies. The Fritzing sketch below shows the connections. Here, the series resistor for the system LED is soldered to the LED cathode, so we do not need a breadboard. The hardware debugger needs a USB connection to your host, but the target does not need to be connected to the host! If it is, then remove the red cable between the 5V pins of the hardware debugger and the target. Warning You need to cut the RESET EN solder bridge on the target board (see section on Requirements concerning the target system )! When you first activate debugWIRE on the UNO target, the target will be completely erased (including the boot loader), because the lock bits have to be cleared. The steps to restore your UNO to its original state are described in the end of the debugging section . States of the hardware debugger We are now good to go and 'only' need to install the additional debugging software on the host. Before we do that, let us have a look, in which states the hardware debugger can be and how it signals that using the system LED. There are five states the debugger can be in and each is signaled by a different blink pattern of the system LED: debugWIRE mode disabled (LED is off), waiting for power-cycling the target (LED flashes every second for 0.1 sec), debugWIRE mode enabled (LED is on) , ISP programming (LED is blinking slowly every 0.5 sec), or error, i.e., it is not possible to connect to the target or there is an internal error (LED blinks furiously every 0.1 sec). If the hardware debugger is in the error state, one should try to find out the reason by typing the command monitor info and studying the error message table at the end of the document. Then finish the GDB session, reset the debugger, and restart everything. I have made the experience that sometimes it is a good idea to disconnect the USB cable and the connection to the target before starting over. If the problem persists, please check the section on troubleshooting .","title":"Hardware setup"},{"location":"setup/#setting-up-the-hardware","text":"Before you can start debugging, you have to set up the hardware. I'll use an ATtiny85 on a breadboard as one example target system. However, any MCU listed above would do as a target. One could even use an Arduino UNO, provided the modifications described in the section on modifying an Uno board have been done.","title":"Setting up the hardware"},{"location":"setup/#debugging-an-attiny85","text":"In order to debug an ATtiny85, we will assume it is completely \"naked\" and plugged into a breadboard as shown below. Notice the capacitor of 10 \u00b5F or more between RESET and GND on the UNO board. This will disable the auto-reset of the UNO board. Second, note the yellow LED connected to pin D7. This is the system LED which is used to visualise the internal state of the debugger (see below). You can also build an LED with a series resistor soldered on and then use pins D6 and D7, where D6 is used as GND. GND and Vcc of the ATtiny are connected to the respective lines on the breadboard, which in turn are connected to GND and 5V of the UNO. Pin D8 of the Arduino UNO is connected to the RESET pin of the ATtiny (pin 1). Note the presence of the pull-up resistor of 10k\u03a9 on the ATtiny RESET pin. The remaining connections between Arduino UNO and ATtiny are MOSI (Arduino UNO D11), MISO (Arduino UNO D12), and SCK (Arduino UNO D13), which you need for ISP programming. In addition, there is an LED connected to pin 3 of the ATtiny chip (which is PB4 or pin D4 in Arduino terminology). The pinout of the ATtiny85 is given in the following figure (with the usual \"counter-clockwise\" numbering of Arduino pins). Here is a table of all the connections so that you can check that you have made all the connections. ATtiny pin# Arduino UNO pin component 1 (Reset) D8 10k resistor to Vcc 2 (D3) 3 (D4) 220 \u03a9 resistor to (red) target LED (+) 4 (GND) GND both LED (-), decoupling cap 100 nF, RESET blocking cap of 10\u00b5F (-) 5 (D0, MOSI) D11 6 (D1, MISO) D12 7 (D2, SCK) D13 8 (Vcc) 5V 10k resistor, decoupling cap 100 nF RESET RESET blocking cap of 10 \u00b5F (+) D7 220 \u03a9 resistor to (yellow) system LED (+)","title":"Debugging an ATtiny85"},{"location":"setup/#debugging-an-uno","text":"If you want to debug an UNO board instead of an ATtiny85, everything said above applies. The Fritzing sketch below shows the connections. Here, the series resistor for the system LED is soldered to the LED cathode, so we do not need a breadboard. The hardware debugger needs a USB connection to your host, but the target does not need to be connected to the host! If it is, then remove the red cable between the 5V pins of the hardware debugger and the target. Warning You need to cut the RESET EN solder bridge on the target board (see section on Requirements concerning the target system )! When you first activate debugWIRE on the UNO target, the target will be completely erased (including the boot loader), because the lock bits have to be cleared. The steps to restore your UNO to its original state are described in the end of the debugging section .","title":"Debugging an UNO"},{"location":"setup/#states-of-the-hardware-debugger","text":"We are now good to go and 'only' need to install the additional debugging software on the host. Before we do that, let us have a look, in which states the hardware debugger can be and how it signals that using the system LED. There are five states the debugger can be in and each is signaled by a different blink pattern of the system LED: debugWIRE mode disabled (LED is off), waiting for power-cycling the target (LED flashes every second for 0.1 sec), debugWIRE mode enabled (LED is on) , ISP programming (LED is blinking slowly every 0.5 sec), or error, i.e., it is not possible to connect to the target or there is an internal error (LED blinks furiously every 0.1 sec). If the hardware debugger is in the error state, one should try to find out the reason by typing the command monitor info and studying the error message table at the end of the document. Then finish the GDB session, reset the debugger, and restart everything. I have made the experience that sometimes it is a good idea to disconnect the USB cable and the connection to the target before starting over. If the problem persists, please check the section on troubleshooting .","title":"States of the hardware debugger"},{"location":"troubleshooting/","text":"Troubleshooting Problems while preparing the setup Problem: It is impossible to upload the dw-link firmware to the UNO board Maybe, the dw-link probe shield or the auto-reset disabling capacitor is still plugged into the UNO board? Remove, and try gain. Startup problems Problems during startup can often be diagnosed when one selects the gdb-server console in the Arduino IDE 2. Problem: In the gdb-server console, the session is terminated right after the message that the gdbserver is waiting for a connection This is an indication that the avr-gdb program could not be started. One could try to solve the problem by getting hold of an avr-gdb version tailored for one's own operating system and replacing the version in the tools folder. The path to this folder is shown in the green line in the gdb-server console. Problem: In the gdb-server console, right after starting the dw-gdbserver (green line), there are a lot of error messages shown This could indicate that the dw-gdbserver binary is incompatible with one's operating system. One may try to solve the problem by building one's own binary. If you have Python Version >= 3.10 and have pipx installed, you can download, generate, and install a version of dw-gdbserver that should work on your OS. Execute pipx install dwgdbserver , and copy the generated binary (try pipx list to locate it on your computer) into the tools folder as shown in the green line in the gdb-server console. Problem: It is impossible to connect to the hardware debugger. In the gdb-server console the message \"No hardware debugger discovered\" is shown One common problem is that the IDE uses the serial line to the debugger for the Serial Monitor . Simply close this console. If this does not help, try to choose a different serial port in the Tools menu. Sometimes, one can no longer connect to the hardware debugger. Try to disconnect and reconnect the USB cable. Next, you may also want to disconnect and reconnect the target. If this happens when the hardware debugger powers the target, this is a sign that the capacitive load of the target may be too high. So, one cure is here to power the target externally and do the power-cycling manually. Problem: When connecting to the target using the target remote command, it takes a long time and then you get the message Remote replied unexpectedly to 'vMustReplyEmpty': timeout This will probably not happen when dw-link is used in the Arduino IDE. The serial connection to the hardware debugger could not be established. The most likely reason for that is that there is a mismatch of the bit rates. The Arduino uses by default 115200 baud, but you can recompile dw-link with a changed value of HOSTBPS , e.g., using 230400. If GDB is told something differently, either as the argument to the -b option when starting avr-gdb or as an argument to the GDB command set serial baud ... , you should change that. If you did not specify the bitrate at all, GDB uses its default speed of 9600, which will not work! My experience is that 230400 bps works only with UNO boards. The Arduino Nano cannot communicate at that speed. A further (unlikely) reason for a failure in connecting to the host might be that a different communication format was chosen (parity, two stop bits, ...). Problem: In response to the monitor debugwire enable command you get the error message Cannot connect: ... ** Depending on the concrete error message, the problem fix varies. Cannot connect: Could not communicate by ISP; check wiring : The debugger cannot establish an ISP connection. Check wiring. Maybe you forgot to power the target board? I did that more than once. If this is not the reason, disconnect everything and put it together again. This helps sometimes. Finally, this error could be caused by having too much capacitive load or a pull-up resistor that is too strong on the RESET line. Cannot connect: Could not activate debugWIRE : An ISP connection was established, but it was not possible to activate debugWIRE. Most probably the MCU is now in a limbo state and can only be resurrected by a HV programmer. The reason is most probably too much capacitive load on the RESET line or a strong pullup resistor on this line. Cannot connect: Unsupported MCU : This MCU is not supported by dw-link. Cannot connect: Lock bits could not be cleared: This should not happen at all because it is always possible to clear the lock bits by erasing the entire chip. Cannot connect: PC with stuck-at-one bits : dw-link tried to connect to an MCU with stuck-at-one bits in the program counter . These MCUs cannot be debugged with GDB. Cannot connect: Reset line has a capacitive load : The message says it all. MCU type does not match : The chip connected to the hardware debugger is different from what you announced when starting the debugger through an IDE or by calling dw-gdbserver. Cannot connect: Target not powered or RESET shortened to GND : The RESET line is low. Either you forgot to power the target, or there is another (maybe temporary?) reason for it. Cannot connect for unknown reasons: This error message should not be shown at all. If it does, please tell me! Problems while debugging Problem: When stopping the program with Ctrl-C (or with the stop button), you get the message Cannot remove breakpoints because program is no longer writable. The reason is most probably that the communication connection to the target system has been lost ( see above ). Problem: When trying to start execution with the run command, GDB stops with an internal error This happens with older avr-gdb versions. You can instead use monitor reset and continue . Problem: The debugger does not start execution and you receive a signal SIGSYS : You use more than the allowed number of breakpoints, i.e., usually 16 (including one for a temporary breakpoint for single-stepping). If you have executed the monitor breakpoint h command, this number is reduced to 1. In this case, you can either set a breakpoint or you can single-step, but not both! In any case, you need to reduce the number of breakpoints before you can continue. SIGBUS : This means that the stack is going to overflow, or a return will fetch its address from an area below the SRAM start when you begin execution. SIGILL : The only reason for such a signal is that at the position we want to continue from, there is a BREAK instruction that the programmer explicitly inserted, or it is a leftover from a previous debugging session that was not cleaned up. In the former case, you may want to change the sketch and restart debugging. In the latter case, a simple load command followed by a restart will do. SIGHUP : The target is not responsive any longer, and the status LED is off. Possible reasons for such a loss of connectivity could be that the RESET line of the target system does not satisfy the necessary electrical requirements . Other reasons might be that the program disturbed the communication by changing, e.g., the MCU clock frequency . Try to identify the reason, eliminate it, and then restart the debug session. Most probably, there are still BREAK instructions in flash memory, so the load command should be used to reload the program. SIGABRT : There was a fatal error and further execution is not possible. The status LED will blink furiously. Check the error number with the monitor info command and look up the reason below . SIGSEGV : Execution was requested to start before the binary was loaded. Use the load command. Problem: When single stepping with next or step , you receive the message Warning: Cannot insert breakpoint 0 and the program is stopped at a strange location The problem is similar to the one above: You used too many breakpoints and there is no temporary breakpoint left for GDB. The program is probably stopped somewhere you have not anticipated. You may be able to recover by deleting one or more breakpoints, setting a breakpoint close to where you wanted to step, and then using the continue command. If this is not possible, restart and use fewer breakpoints. Strange behavior of the debugger Problem: After changing optimization options, the binary is still too large/very small You switched the optimization option from -Og -fno-lto back to normal and you recompiled, but your program still looks very big. The reason for that can be that the Arduino IDE/CLI does not always recompile the core, but reuses the compiled and linked archive. In the Arduino IDE 1, you can force a recompile of the core by exiting the IDE. In IDE 2, this option is no longer available. You need to locate the compiled files and delete them manually. Problem: The debugger responses are very sluggish One reason for that could be that the target is run with a clock less than 1 MHz, e.g. at 128 kHz. Since the debugWIRE communication speed is usually clock/8, the debugWIRE communication speed could be 16kbps. If the CKDIV8 fuse is programmed, it could even be only 2kbps. Unprogram CKDIV8 and if possible choose a higher clock frequency . Problem: While single-stepping, time seems to be frozen, i.e., the timers do not advance and no timer interrupt is raised This is a feature, not a bug. It allows you to single-step through the code without being distracted by interrupts that transfer the control to the interrupt service routine. Time passes and interrupts are raised only when you use the continue command (or when the next command skips over a function call). You can change this behavior by using the command monitor singlestep i , which enables the timers and interrupts while single-stepping. In this case, however, it may happen that during single-stepping control is transferred into an interrupt routine. Problem: PWM (analogWrite) does not seem to work when the program is stopped The reason is that all timers are usually stopped when the program is in a stopped state. However, you can change this behavior using the GDB command monitor timers run . In this case, the timers are run even when the program is stopped, which means that PWM (aka analogWrite ) is also still active. Actually, this is the default behavior! Problem: When single stepping with next or step , the program ends up at the start of flash memory, e.g., 0x0030 This should only happen when you have used the command monitor singlestep interruptible before, which enables interrupts while single-stepping. In this case, an interrupt might have been raised which has transferred control to the interrupt vector table at the beginning of flash memory. If you want to continue debugging, set a breakpoint at the line you planned to stop with the single-step command and use the continue command. If you want to avoid this behavior in the future, issue the debugger command monitor singlestep safe . Problem: After requesting to stop at a function, the debugger displays a completely different file, where the execution will stop This is a GDB problem. It can happen when a function call is inlined at the beginning of the function one intends to stop at. While the place where execution will stop looks crazy (e.g., HardwareSerial.h at line 121), the execution stops indeed at the beginning of the specified function (in this case at the beginning of setup). Problem: The debugger does not stop at the line a breakpoint was set Not all source lines generate machine code so that it is sometimes impossible to stop at a given line. The debugger will then try to stop at the next possible line. This effect can get worse with different compiler optimization levels. For debugging, -Og3 is the recommended optimization option, which applies optimizations in a debug-friendly way. This is also the default for PlatformIO. In the Arduino IDE, you have to activate the Optimize for Debugging switch in the Sketch menu. Problem: The debugger does things that appear to be strange The debugger starts execution, but it never stops at a breakpoint it should stop, single-stepping does not lead to the expected results, etc. I have seen three possible reasons for that (apart from a programming error that you are hunting). Often, I had forgotten to load the binary code into flash. Remember to use the load command every time after you have started a debugging session. Otherwise it may be the case that the MCU flash memory contains old code! Note that after the load command the program counter is set to zero. However, the MCU and its registers have not been reset. You should probably force a hardware reset by using the command monitor reset . Alternatively, when you initiated your session with target extended-remote ... , you can use the run command that resets the MCU and starts at address zero. In the Arduino IDE 2, all these problems will not happen. Second, you may have specified a board/MCU different from your actual target. This happens quite easily with PlatformIO when you work with different targets. In this case, some things appear to work, but others do not work at all. Again, in the Arduino IDE 2, this cannot happen. Another possible reason for strange behavior is the chosen compiler optimization level. If you have not chosen -Og3 , then single-stepping may not work as expected and/or you may not be able to assign values to local variables. If objects are not printed the right way, then you may consider disabling LTO (by using the compiler option -fno-lto ). So, before blaming the debugger, check for the three possible causes. Problems with with GUI/IDE Problem: When starting the debug session in PlatformIO, you get the message *pioinit:XX: Error in sourced command file Something in the platformio.ini file is not quite right. Sometimes an additional line of information is given that identifies the problem. If you see also see the message \"monitor\" command not supported by this target then the dw-link adapter could not be found. One other common problem is that the debug environment is not the first environment or the default environment. In this case, the wrong environment is used to configure the debug session and probably some environment variables are not set at all or set to the wrong values. So, you need to edit the platformio.ini file accordingly. Problems after debugging Problem: After debugging, the chip is unresponsive, i.e., does not respond anymore to ISP programming or bootloader upload** There are many possible causes: The DWEN fuse is still programmed, i.e., the MCU is still in debugWIRE mode. In this case, it may help to enter and leave the debugger again, provided that there are not any problems with the RESET line . It may also be helpful to issue the command monitor debugwire disable . Another fuse has been programmed by accident. In particular, there are the monitor commands that change the clock source. If an external clock or an XTAL has been chosen, then you can recover the chip only by providing such an external clock or XTAL and then use either ISP programming or connect again to dw-link. Apparently it happens that the MCU is stuck halfway when transitioning to debugWIRE state. If nothing helps, then high-voltage programming might still be a last resort. Internal and fatal debugger errors Problem: The system LED blinks furiously and/or the program receives an ABORT signal when trying to start execution In this case some serious internal error had happened. You have to stop the current debug session and restart. The reason for such an error could be that the connection to the target could not be established or that there was an internal debugger error. It may be that the corresponding error message has already been displayed. You can find out what kind of error happened by typing the following command: monitor info If the error number is less than 100, then it is a connection error. Try again, perhaps after disconnecting and reconnecting everything. Check wiring. If the error persists, try perhaps with a different MCU. Errors above 100 are serious internal debugger errors. If you have encountered such an internal debugger error, then please try to reproduce the problem and tell me how it happened. After a reset or a power cycle of the hardware debugger, everything usually works again. If not, you need to unplug everything and put it together again. Error # Meaning 1 Could not communicate by ISP; check wiring 2 Could not activate debugWIRE 3 MCU type is not supported 4 Lockbits could not be cleared 5 Lockbits are set but not managed by dw-link 6 BOOTRST fuse could not be cleared 7 MCU has a program counter with stuck-at-one bits 8 RESET line has a capacitive load 9 Target not powered or RESET shortened to GND 10 MCU type does not match 11 DWEN fuse could not be programmed 12 DWEN fuse is unprogrammed but not managed by dw-link 13 EESAVE fuse could not be changed 14 Unknown connection error 101 No free slot in breakpoint table 102 Packet length too large 103 Wrong memory type 104 Packet length is negative 105 Reset operation failed 106 Memory address in flash read operation does not point to page start 107 Could not complete flash read operation 108 Could not complete RAM read operation 109 Memory address in flash write operation does not point to page start 110 Could not complete flash page erase operation 111 Could not load data into the flash buffer for writing 112 Error when programming flash page from buffer 113 Error verifying flashed page while loading program 114 Assignment of hardware breakpoint is inconsistent 115 BREAK inserted by debugger at a point where a step or execute operation is required 116 Trying to read flash word at an uneven address 117 Error when single-stepping 118 A relevant breakpoint has disappeared 119 Input buffer overflow 120 Wrong fuse 121 Breakpoint update while flash programming is active 122 Timeout while reading from debugWIRE line 123 Timeout while reading general register 124 Timeout while reading IO register 125 Could not reenable RWW 126 Failure while reading from EEPROM 127 Bad interrupt 128 Inconsistent classification of opcodes in range-stepping","title":"Troubleshooting"},{"location":"troubleshooting/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"troubleshooting/#problems-while-preparing-the-setup","text":"","title":"Problems while preparing the setup"},{"location":"troubleshooting/#problem-it-is-impossible-to-upload-the-dw-link-firmware-to-the-uno-board","text":"Maybe, the dw-link probe shield or the auto-reset disabling capacitor is still plugged into the UNO board? Remove, and try gain.","title":"Problem: It is impossible to upload the dw-link firmware to the UNO board"},{"location":"troubleshooting/#startup-problems","text":"Problems during startup can often be diagnosed when one selects the gdb-server console in the Arduino IDE 2.","title":"Startup problems"},{"location":"troubleshooting/#problem-in-the-gdb-server-console-the-session-is-terminated-right-after-the-message-that-the-gdbserver-is-waiting-for-a-connection","text":"This is an indication that the avr-gdb program could not be started. One could try to solve the problem by getting hold of an avr-gdb version tailored for one's own operating system and replacing the version in the tools folder. The path to this folder is shown in the green line in the gdb-server console.","title":"Problem: In the gdb-server console, the session is terminated right after the message that the gdbserver is waiting for a connection"},{"location":"troubleshooting/#problem-in-the-gdb-server-console-right-after-starting-the-dw-gdbserver-green-line-there-are-a-lot-of-error-messages-shown","text":"This could indicate that the dw-gdbserver binary is incompatible with one's operating system. One may try to solve the problem by building one's own binary. If you have Python Version >= 3.10 and have pipx installed, you can download, generate, and install a version of dw-gdbserver that should work on your OS. Execute pipx install dwgdbserver , and copy the generated binary (try pipx list to locate it on your computer) into the tools folder as shown in the green line in the gdb-server console.","title":"Problem: In the gdb-server console, right after starting the dw-gdbserver (green line), there are a lot of error messages shown"},{"location":"troubleshooting/#problem-it-is-impossible-to-connect-to-the-hardware-debugger-in-the-gdb-server-console-the-message-no-hardware-debugger-discovered-is-shown","text":"One common problem is that the IDE uses the serial line to the debugger for the Serial Monitor . Simply close this console. If this does not help, try to choose a different serial port in the Tools menu. Sometimes, one can no longer connect to the hardware debugger. Try to disconnect and reconnect the USB cable. Next, you may also want to disconnect and reconnect the target. If this happens when the hardware debugger powers the target, this is a sign that the capacitive load of the target may be too high. So, one cure is here to power the target externally and do the power-cycling manually.","title":"Problem: It is impossible to connect to the hardware debugger. In the gdb-server console the message \"No hardware debugger discovered\" is shown"},{"location":"troubleshooting/#problem-when-connecting-to-the-target-using-the-target-remote-command-it-takes-a-long-time-and-then-you-get-the-message-remote-replied-unexpectedly-to-vmustreplyempty-timeout","text":"This will probably not happen when dw-link is used in the Arduino IDE. The serial connection to the hardware debugger could not be established. The most likely reason for that is that there is a mismatch of the bit rates. The Arduino uses by default 115200 baud, but you can recompile dw-link with a changed value of HOSTBPS , e.g., using 230400. If GDB is told something differently, either as the argument to the -b option when starting avr-gdb or as an argument to the GDB command set serial baud ... , you should change that. If you did not specify the bitrate at all, GDB uses its default speed of 9600, which will not work! My experience is that 230400 bps works only with UNO boards. The Arduino Nano cannot communicate at that speed. A further (unlikely) reason for a failure in connecting to the host might be that a different communication format was chosen (parity, two stop bits, ...).","title":"Problem: When connecting to the target using the target remote command, it takes a long time and then you get the message Remote replied unexpectedly to 'vMustReplyEmpty': timeout"},{"location":"troubleshooting/#problem-in-response-to-the-monitor-debugwire-enable-command-you-get-the-error-message-cannot-connect","text":"Depending on the concrete error message, the problem fix varies. Cannot connect: Could not communicate by ISP; check wiring : The debugger cannot establish an ISP connection. Check wiring. Maybe you forgot to power the target board? I did that more than once. If this is not the reason, disconnect everything and put it together again. This helps sometimes. Finally, this error could be caused by having too much capacitive load or a pull-up resistor that is too strong on the RESET line. Cannot connect: Could not activate debugWIRE : An ISP connection was established, but it was not possible to activate debugWIRE. Most probably the MCU is now in a limbo state and can only be resurrected by a HV programmer. The reason is most probably too much capacitive load on the RESET line or a strong pullup resistor on this line. Cannot connect: Unsupported MCU : This MCU is not supported by dw-link. Cannot connect: Lock bits could not be cleared: This should not happen at all because it is always possible to clear the lock bits by erasing the entire chip. Cannot connect: PC with stuck-at-one bits : dw-link tried to connect to an MCU with stuck-at-one bits in the program counter . These MCUs cannot be debugged with GDB. Cannot connect: Reset line has a capacitive load : The message says it all. MCU type does not match : The chip connected to the hardware debugger is different from what you announced when starting the debugger through an IDE or by calling dw-gdbserver. Cannot connect: Target not powered or RESET shortened to GND : The RESET line is low. Either you forgot to power the target, or there is another (maybe temporary?) reason for it. Cannot connect for unknown reasons: This error message should not be shown at all. If it does, please tell me!","title":"Problem: In response to the monitor debugwire enable command you get the error message Cannot connect: ...**"},{"location":"troubleshooting/#problems-while-debugging","text":"","title":"Problems while debugging"},{"location":"troubleshooting/#problem-when-stopping-the-program-with-ctrl-c-or-with-the-stop-button-you-get-the-message-cannot-remove-breakpoints-because-program-is-no-longer-writable","text":"The reason is most probably that the communication connection to the target system has been lost ( see above ).","title":"Problem: When stopping the program with Ctrl-C (or with the stop button), you get the message Cannot remove breakpoints because program is no longer writable."},{"location":"troubleshooting/#problem-when-trying-to-start-execution-with-the-run-command-gdb-stops-with-an-internal-error","text":"This happens with older avr-gdb versions. You can instead use monitor reset and continue .","title":"Problem: When trying to start execution with the run command, GDB stops with an internal error"},{"location":"troubleshooting/#problem-the-debugger-does-not-start-execution-and-you-receive-a-signal","text":"SIGSYS : You use more than the allowed number of breakpoints, i.e., usually 16 (including one for a temporary breakpoint for single-stepping). If you have executed the monitor breakpoint h command, this number is reduced to 1. In this case, you can either set a breakpoint or you can single-step, but not both! In any case, you need to reduce the number of breakpoints before you can continue. SIGBUS : This means that the stack is going to overflow, or a return will fetch its address from an area below the SRAM start when you begin execution. SIGILL : The only reason for such a signal is that at the position we want to continue from, there is a BREAK instruction that the programmer explicitly inserted, or it is a leftover from a previous debugging session that was not cleaned up. In the former case, you may want to change the sketch and restart debugging. In the latter case, a simple load command followed by a restart will do. SIGHUP : The target is not responsive any longer, and the status LED is off. Possible reasons for such a loss of connectivity could be that the RESET line of the target system does not satisfy the necessary electrical requirements . Other reasons might be that the program disturbed the communication by changing, e.g., the MCU clock frequency . Try to identify the reason, eliminate it, and then restart the debug session. Most probably, there are still BREAK instructions in flash memory, so the load command should be used to reload the program. SIGABRT : There was a fatal error and further execution is not possible. The status LED will blink furiously. Check the error number with the monitor info command and look up the reason below . SIGSEGV : Execution was requested to start before the binary was loaded. Use the load command.","title":"Problem: The debugger does not start execution and you receive a signal"},{"location":"troubleshooting/#problem-when-single-stepping-with-next-or-step-you-receive-the-message-warning-cannot-insert-breakpoint-0-and-the-program-is-stopped-at-a-strange-location","text":"The problem is similar to the one above: You used too many breakpoints and there is no temporary breakpoint left for GDB. The program is probably stopped somewhere you have not anticipated. You may be able to recover by deleting one or more breakpoints, setting a breakpoint close to where you wanted to step, and then using the continue command. If this is not possible, restart and use fewer breakpoints.","title":"Problem: When single stepping with next or step , you receive the message Warning: Cannot insert breakpoint 0 and the program is stopped at a strange location"},{"location":"troubleshooting/#strange-behavior-of-the-debugger","text":"","title":"Strange behavior of the debugger"},{"location":"troubleshooting/#problem-after-changing-optimization-options-the-binary-is-still-too-largevery-small","text":"You switched the optimization option from -Og -fno-lto back to normal and you recompiled, but your program still looks very big. The reason for that can be that the Arduino IDE/CLI does not always recompile the core, but reuses the compiled and linked archive. In the Arduino IDE 1, you can force a recompile of the core by exiting the IDE. In IDE 2, this option is no longer available. You need to locate the compiled files and delete them manually.","title":"Problem: After changing optimization options, the binary is still too large/very small"},{"location":"troubleshooting/#problem-the-debugger-responses-are-very-sluggish","text":"One reason for that could be that the target is run with a clock less than 1 MHz, e.g. at 128 kHz. Since the debugWIRE communication speed is usually clock/8, the debugWIRE communication speed could be 16kbps. If the CKDIV8 fuse is programmed, it could even be only 2kbps. Unprogram CKDIV8 and if possible choose a higher clock frequency .","title":"Problem: The debugger responses are very sluggish"},{"location":"troubleshooting/#problem-while-single-stepping-time-seems-to-be-frozen-ie-the-timers-do-not-advance-and-no-timer-interrupt-is-raised","text":"This is a feature, not a bug. It allows you to single-step through the code without being distracted by interrupts that transfer the control to the interrupt service routine. Time passes and interrupts are raised only when you use the continue command (or when the next command skips over a function call). You can change this behavior by using the command monitor singlestep i , which enables the timers and interrupts while single-stepping. In this case, however, it may happen that during single-stepping control is transferred into an interrupt routine.","title":"Problem: While single-stepping, time seems to be frozen, i.e., the timers do not advance and no timer interrupt is raised"},{"location":"troubleshooting/#problem-pwm-analogwrite-does-not-seem-to-work-when-the-program-is-stopped","text":"The reason is that all timers are usually stopped when the program is in a stopped state. However, you can change this behavior using the GDB command monitor timers run . In this case, the timers are run even when the program is stopped, which means that PWM (aka analogWrite ) is also still active. Actually, this is the default behavior!","title":"Problem: PWM (analogWrite) does not seem to work when the program is stopped"},{"location":"troubleshooting/#problem-when-single-stepping-with-next-or-step-the-program-ends-up-at-the-start-of-flash-memory-eg-0x0030","text":"This should only happen when you have used the command monitor singlestep interruptible before, which enables interrupts while single-stepping. In this case, an interrupt might have been raised which has transferred control to the interrupt vector table at the beginning of flash memory. If you want to continue debugging, set a breakpoint at the line you planned to stop with the single-step command and use the continue command. If you want to avoid this behavior in the future, issue the debugger command monitor singlestep safe .","title":"Problem: When single stepping with next or step , the program ends up at the start of flash memory, e.g., 0x0030"},{"location":"troubleshooting/#problem-after-requesting-to-stop-at-a-function-the-debugger-displays-a-completely-different-file-where-the-execution-will-stop","text":"This is a GDB problem. It can happen when a function call is inlined at the beginning of the function one intends to stop at. While the place where execution will stop looks crazy (e.g., HardwareSerial.h at line 121), the execution stops indeed at the beginning of the specified function (in this case at the beginning of setup).","title":"Problem: After requesting to stop at a function, the debugger displays a completely different file, where the execution will stop"},{"location":"troubleshooting/#problem-the-debugger-does-not-stop-at-the-line-a-breakpoint-was-set","text":"Not all source lines generate machine code so that it is sometimes impossible to stop at a given line. The debugger will then try to stop at the next possible line. This effect can get worse with different compiler optimization levels. For debugging, -Og3 is the recommended optimization option, which applies optimizations in a debug-friendly way. This is also the default for PlatformIO. In the Arduino IDE, you have to activate the Optimize for Debugging switch in the Sketch menu.","title":"Problem: The debugger does not stop at the line a breakpoint was set"},{"location":"troubleshooting/#problem-the-debugger-does-things-that-appear-to-be-strange","text":"The debugger starts execution, but it never stops at a breakpoint it should stop, single-stepping does not lead to the expected results, etc. I have seen three possible reasons for that (apart from a programming error that you are hunting). Often, I had forgotten to load the binary code into flash. Remember to use the load command every time after you have started a debugging session. Otherwise it may be the case that the MCU flash memory contains old code! Note that after the load command the program counter is set to zero. However, the MCU and its registers have not been reset. You should probably force a hardware reset by using the command monitor reset . Alternatively, when you initiated your session with target extended-remote ... , you can use the run command that resets the MCU and starts at address zero. In the Arduino IDE 2, all these problems will not happen. Second, you may have specified a board/MCU different from your actual target. This happens quite easily with PlatformIO when you work with different targets. In this case, some things appear to work, but others do not work at all. Again, in the Arduino IDE 2, this cannot happen. Another possible reason for strange behavior is the chosen compiler optimization level. If you have not chosen -Og3 , then single-stepping may not work as expected and/or you may not be able to assign values to local variables. If objects are not printed the right way, then you may consider disabling LTO (by using the compiler option -fno-lto ). So, before blaming the debugger, check for the three possible causes.","title":"Problem: The debugger does things that appear to be strange"},{"location":"troubleshooting/#problems-with-with-guiide","text":"","title":"Problems with with GUI/IDE"},{"location":"troubleshooting/#problem-when-starting-the-debug-session-in-platformio-you-get-the-message-pioinitxx-error-in-sourced-command-file","text":"Something in the platformio.ini file is not quite right. Sometimes an additional line of information is given that identifies the problem. If you see also see the message \"monitor\" command not supported by this target then the dw-link adapter could not be found. One other common problem is that the debug environment is not the first environment or the default environment. In this case, the wrong environment is used to configure the debug session and probably some environment variables are not set at all or set to the wrong values. So, you need to edit the platformio.ini file accordingly.","title":"Problem: When starting the debug session in PlatformIO, you get the message *pioinit:XX: Error in sourced command file"},{"location":"troubleshooting/#problems-after-debugging","text":"","title":"Problems after debugging"},{"location":"troubleshooting/#problem-after-debugging-the-chip-is-unresponsive-ie-does-not-respond-anymore-to-isp-programming-or-bootloader-upload","text":"There are many possible causes: The DWEN fuse is still programmed, i.e., the MCU is still in debugWIRE mode. In this case, it may help to enter and leave the debugger again, provided that there are not any problems with the RESET line . It may also be helpful to issue the command monitor debugwire disable . Another fuse has been programmed by accident. In particular, there are the monitor commands that change the clock source. If an external clock or an XTAL has been chosen, then you can recover the chip only by providing such an external clock or XTAL and then use either ISP programming or connect again to dw-link. Apparently it happens that the MCU is stuck halfway when transitioning to debugWIRE state. If nothing helps, then high-voltage programming might still be a last resort.","title":"Problem: After debugging, the chip is unresponsive, i.e., does not respond anymore to ISP programming or bootloader upload**"},{"location":"troubleshooting/#internal-and-fatal-debugger-errors","text":"","title":"Internal and fatal debugger errors"},{"location":"troubleshooting/#problem-the-system-led-blinks-furiously-andor-the-program-receives-an-abort-signal-when-trying-to-start-execution","text":"In this case some serious internal error had happened. You have to stop the current debug session and restart. The reason for such an error could be that the connection to the target could not be established or that there was an internal debugger error. It may be that the corresponding error message has already been displayed. You can find out what kind of error happened by typing the following command: monitor info If the error number is less than 100, then it is a connection error. Try again, perhaps after disconnecting and reconnecting everything. Check wiring. If the error persists, try perhaps with a different MCU. Errors above 100 are serious internal debugger errors. If you have encountered such an internal debugger error, then please try to reproduce the problem and tell me how it happened. After a reset or a power cycle of the hardware debugger, everything usually works again. If not, you need to unplug everything and put it together again. Error # Meaning 1 Could not communicate by ISP; check wiring 2 Could not activate debugWIRE 3 MCU type is not supported 4 Lockbits could not be cleared 5 Lockbits are set but not managed by dw-link 6 BOOTRST fuse could not be cleared 7 MCU has a program counter with stuck-at-one bits 8 RESET line has a capacitive load 9 Target not powered or RESET shortened to GND 10 MCU type does not match 11 DWEN fuse could not be programmed 12 DWEN fuse is unprogrammed but not managed by dw-link 13 EESAVE fuse could not be changed 14 Unknown connection error 101 No free slot in breakpoint table 102 Packet length too large 103 Wrong memory type 104 Packet length is negative 105 Reset operation failed 106 Memory address in flash read operation does not point to page start 107 Could not complete flash read operation 108 Could not complete RAM read operation 109 Memory address in flash write operation does not point to page start 110 Could not complete flash page erase operation 111 Could not load data into the flash buffer for writing 112 Error when programming flash page from buffer 113 Error verifying flashed page while loading program 114 Assignment of hardware breakpoint is inconsistent 115 BREAK inserted by debugger at a point where a step or execute operation is required 116 Trying to read flash word at an uneven address 117 Error when single-stepping 118 A relevant breakpoint has disappeared 119 Input buffer overflow 120 Wrong fuse 121 Breakpoint update while flash programming is active 122 Timeout while reading from debugWIRE line 123 Timeout while reading general register 124 Timeout while reading IO register 125 Could not reenable RWW 126 Failure while reading from EEPROM 127 Bad interrupt 128 Inconsistent classification of opcodes in range-stepping","title":"Problem: The system LED blinks furiously and/or the program receives an ABORT signal when trying to start execution"},{"location":"wishlist/","text":"Wish list for dw-link List of tasks to work on: maybe have a variable length break, dependent on the speed of ISP? implement semi-hosting Check for output of error routines. Sometimes it does not seem to work List of tasks done: being able to receive qRcmd commands before the actual debugging starts (would allow to pass pyAvrOCD monitor options to debugger) Implement range-stepping with one HWBP Prohibit debug sleep-crash when single- stepping. debug tiny13 problem, perhaps by reverting back to the version in 2022, when it seemed to work - was actually the _delay_ms problem Create Python script dw-gdbserver.py that implements a dw server on top of pymcuprog Build a V5 version: unified monitor commands and tight integration into the script; power-cycling is now only initiated by monitor debugwire enable a mode where writes are double-checked: \"monitor verify/noverify\". Could be on or off by default. produce short youtube video to promote dw-link probe Write a step-by-step explanation on how to restore an UNO after debugging try integration of tool into IDE 2.0 again clean up Gede interface no multiple main breakspoints reloading files in GUI when reloading files write a short debug description for PIO write/design setup for UNO debugging with connected USB cable rewrite compile-time conditionals so that they do not show up as errors in PIO use DEBTX pin (if TXODEBUG is not defined) as a sensing pin to disable automatic DWEN programming, i.e., you have to use mo dw +/- by yourself. optimize ispTransfer so that higher ISP rates are possible (currently, 50 kHz is max) important (3.1.0): When trying to debug the boarduino at 5V with the probe shield, the feedback is: Wrong Wiring . It works flawlessly with a lot of other boards (ATtiny, UNO, ...), with other shields, with 5V, you name it --> turned out to be that the boarduino had a particularly strong pull-down resistor. That is, the cure is to use 1K or stringer pull-ups on the SPI lines! monitor clock command that displays the current clock setting -- well, redesigned all monitor commands! integrate programmer into code so that one also could do ISP programming design new adapter board test prototype of such a board Adding response in dw-link to one special byte in order to be able to identify the debug serial port writing Python function for identifying debug port Erasing MCU automatically when lock bits are set write hook to set UPLOAD_PORT and DEBUG_PORT in extra_script. Explaining how to recover UNO (soldering + Bootloader burning) in Manual remove part about lock bits in Manual remove automatic speed recognition delete the fancy control stuff in dw-link rewrite part in manual about adapter boards rewrite part in Manual about PlatformIO List of tasks abandoned : Use \"blinkmodes.ino\" in order to highlight embedded programming, perhaps in a video? Something to be done for PyAvrOCD. Implement STK500v2 protocol design case for debugger and print it try to use seer GUI again integrate into the Arduino VSC plugin reorganize BP management: have a list of stored and a list of new BPs, which would save us 3 bytes per BP, i.e., we could easily go from 25 to 30 BPs -- but be careful! perhaps make conditional/repeating breakpoints faster: less register saving/restoring (would give you perhaps 10 ms out of 40 ms), shorter pauses by GDB (but where to control this?)","title":"Wish list for dw-link"},{"location":"wishlist/#wish-list-for-dw-link","text":"","title":"Wish list for dw-link"},{"location":"wishlist/#list-of-tasks-to-work-on","text":"maybe have a variable length break, dependent on the speed of ISP? implement semi-hosting Check for output of error routines. Sometimes it does not seem to work","title":"List of tasks to work on:"},{"location":"wishlist/#list-of-tasks-done","text":"being able to receive qRcmd commands before the actual debugging starts (would allow to pass pyAvrOCD monitor options to debugger) Implement range-stepping with one HWBP Prohibit debug sleep-crash when single- stepping. debug tiny13 problem, perhaps by reverting back to the version in 2022, when it seemed to work - was actually the _delay_ms problem Create Python script dw-gdbserver.py that implements a dw server on top of pymcuprog Build a V5 version: unified monitor commands and tight integration into the script; power-cycling is now only initiated by monitor debugwire enable a mode where writes are double-checked: \"monitor verify/noverify\". Could be on or off by default. produce short youtube video to promote dw-link probe Write a step-by-step explanation on how to restore an UNO after debugging try integration of tool into IDE 2.0 again clean up Gede interface no multiple main breakspoints reloading files in GUI when reloading files write a short debug description for PIO write/design setup for UNO debugging with connected USB cable rewrite compile-time conditionals so that they do not show up as errors in PIO use DEBTX pin (if TXODEBUG is not defined) as a sensing pin to disable automatic DWEN programming, i.e., you have to use mo dw +/- by yourself. optimize ispTransfer so that higher ISP rates are possible (currently, 50 kHz is max) important (3.1.0): When trying to debug the boarduino at 5V with the probe shield, the feedback is: Wrong Wiring . It works flawlessly with a lot of other boards (ATtiny, UNO, ...), with other shields, with 5V, you name it --> turned out to be that the boarduino had a particularly strong pull-down resistor. That is, the cure is to use 1K or stringer pull-ups on the SPI lines! monitor clock command that displays the current clock setting -- well, redesigned all monitor commands! integrate programmer into code so that one also could do ISP programming design new adapter board test prototype of such a board Adding response in dw-link to one special byte in order to be able to identify the debug serial port writing Python function for identifying debug port Erasing MCU automatically when lock bits are set write hook to set UPLOAD_PORT and DEBUG_PORT in extra_script. Explaining how to recover UNO (soldering + Bootloader burning) in Manual remove part about lock bits in Manual remove automatic speed recognition delete the fancy control stuff in dw-link rewrite part in manual about adapter boards rewrite part in Manual about PlatformIO List of tasks abandoned : Use \"blinkmodes.ino\" in order to highlight embedded programming, perhaps in a video? Something to be done for PyAvrOCD. Implement STK500v2 protocol design case for debugger and print it try to use seer GUI again integrate into the Arduino VSC plugin reorganize BP management: have a list of stored and a list of new BPs, which would save us 3 bytes per BP, i.e., we could easily go from 25 to 30 BPs -- but be careful! perhaps make conditional/repeating breakpoints faster: less register saving/restoring (would give you perhaps 10 ms out of 40 ms), shorter pauses by GDB (but where to control this?)","title":"List of tasks done:"}]}